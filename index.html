<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ben Sniper - Deriv Trading Bot</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 100%);
            color: #e0e0e0;
            min-height: 100vh;
            padding: 10px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            background: linear-gradient(135deg, #1e2749 0%, #2d3561 100%);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            position: relative;
        }

        .connection-badge {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 20px;
            border: 2px solid;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            transition: all 0.3s ease;
        }

        .connection-badge.connected {
            border-color: #2ecc71;
            color: #2ecc71;
        }

        .connection-badge.disconnected {
            border-color: #ff4757;
            color: #ff4757;
        }

        .connection-badge-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            animation: badge-pulse 2s infinite;
        }

        .connection-badge.connected .connection-badge-dot {
            background-color: #2ecc71;
        }

        .connection-badge.disconnected .connection-badge-dot {
            background-color: #ff4757;
        }

        @keyframes badge-pulse {
            0%, 100% {
                opacity: 1;
                transform: scale(1);
            }
            50% {
                opacity: 0.6;
                transform: scale(1.2);
            }
        }

        .header h1 {
            color: #00d4ff;
            font-size: 28px;
            margin-bottom: 15px;
            text-align: center;
            padding-right: 150px;
        }

        .login-section {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 15px;
        }

        .login-input-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .login-input {
            flex: 1;
            min-width: 200px;
            padding: 12px;
            background: #2a3250;
            border: 2px solid #3d4663;
            border-radius: 5px;
            color: #e0e0e0;
            font-size: 14px;
        }

        .login-input:focus {
            outline: none;
            border-color: #00d4ff;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }

        .btn-primary {
            background: linear-gradient(135deg, #00d4ff 0%, #0099cc 100%);
            color: #0a0e27;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 212, 255, 0.4);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ff4757 0%, #cc3544 100%);
            color: white;
        }

        .btn-danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(255, 71, 87, 0.4);
        }

        .btn-success {
            background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
            color: white;
        }

        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(46, 204, 113, 0.4);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .account-info {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 10px;
            padding: 15px;
            background: rgba(0, 212, 255, 0.1);
            border-radius: 5px;
            margin-top: 10px;
        }

        .info-item {
            text-align: center;
        }

        .info-label {
            font-size: 11px;
            color: #8899aa;
            text-transform: uppercase;
        }

        .info-value {
            font-size: 16px;
            font-weight: 700;
            color: #00d4ff;
            margin-top: 5px;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .panel {
            background: #1e2749;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .panel-title {
            color: #00d4ff;
            font-size: 18px;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #3d4663;
        }

        .markets-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }

        .market-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: #2a3250;
            border-radius: 5px;
            border: 1px solid #3d4663;
            position: relative;
        }

        .market-left {
            display: flex;
            align-items: center;
            gap: 10px;
            flex: 1;
        }

        .market-status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: #3d4663;
            transition: all 0.3s ease;
            flex-shrink: 0;
        }

        .market-status-dot.subscribed {
            background-color: #2ecc71;
            box-shadow: 0 0 10px #2ecc71, 0 0 20px #2ecc71, 0 0 30px #2ecc71;
            animation: glow-pulse 2s infinite;
        }

        .market-status-dot.failed {
            background-color: #ff4757;
            box-shadow: 0 0 10px #ff4757;
        }

        .market-status-dot.subscribing {
            background-color: #f39c12;
            animation: blink 1s infinite;
        }

        @keyframes glow-pulse {
            0%, 100% {
                box-shadow: 0 0 5px #2ecc71, 0 0 10px #2ecc71, 0 0 15px #2ecc71;
            }
            50% {
                box-shadow: 0 0 10px #2ecc71, 0 0 20px #2ecc71, 0 0 30px #2ecc71;
            }
        }

        @keyframes blink {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.3;
            }
        }

        .market-name {
            font-size: 13px;
            color: #e0e0e0;
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #3d4663;
            transition: 0.3s;
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #00d4ff;
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }

        .filter-section {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 15px;
        }

        .filter-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            background: #2a3250;
            border-radius: 5px;
            border: 1px solid #3d4663;
        }

        .filter-label {
            font-size: 14px;
            color: #e0e0e0;
        }

        .settings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .input-label {
            font-size: 12px;
            color: #8899aa;
            text-transform: uppercase;
        }

        .input-field {
            padding: 10px;
            background: #2a3250;
            border: 2px solid #3d4663;
            border-radius: 5px;
            color: #e0e0e0;
            font-size: 14px;
        }

        .input-field:focus {
            outline: none;
            border-color: #00d4ff;
        }

        .select-field {
            padding: 10px;
            background: #2a3250;
            border: 2px solid #3d4663;
            border-radius: 5px;
            color: #e0e0e0;
            font-size: 14px;
            cursor: pointer;
        }

        .select-field:focus {
            outline: none;
            border-color: #00d4ff;
        }

        .control-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .control-buttons .btn {
            flex: 1;
            min-width: 120px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .stat-card {
            background: #2a3250;
            padding: 15px;
            border-radius: 5px;
            text-align: center;
            border: 1px solid #3d4663;
        }

        .stat-label {
            font-size: 11px;
            color: #8899aa;
            text-transform: uppercase;
            margin-bottom: 8px;
        }

        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: #00d4ff;
        }

        .stat-value.profit {
            color: #2ecc71;
        }

        .stat-value.loss {
            color: #ff4757;
        }

        .signal-monitor {
            background: #1e2749;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            margin-bottom: 20px;
        }

        .monitor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 15px;
            background: #2a3250;
            border-radius: 20px;
        }

        .pulse-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #ff4757;
            animation: pulse 2s infinite;
        }

        .pulse-dot.active {
            background-color: #2ecc71;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
                transform: scale(1);
            }
            50% {
                opacity: 0.5;
                transform: scale(1.1);
            }
        }

        .status-text {
            font-size: 13px;
            color: #ff4757;
            font-weight: 600;
        }

        .status-text.active {
            color: #2ecc71;
        }

        .signals-container {
            max-height: 300px;
            overflow-y: auto;
            background: #0a0e27;
            padding: 15px;
            border-radius: 5px;
        }

        .signals-container::-webkit-scrollbar {
            width: 8px;
        }

        .signals-container::-webkit-scrollbar-track {
            background: #1e2749;
            border-radius: 10px;
        }

        .signals-container::-webkit-scrollbar-thumb {
            background: #00d4ff;
            border-radius: 10px;
        }

        .signal-item {
            padding: 12px;
            margin-bottom: 10px;
            border-radius: 5px;
            border-left: 4px solid #3d4663;
            background: #1e2749;
            transition: all 0.3s ease;
        }

        .signal-item.buy {
            border-left-color: #00d4ff;
            background: rgba(0, 212, 255, 0.1);
        }

        .signal-item.sell {
            border-left-color: #f39c12;
            background: rgba(243, 156, 18, 0.1);
        }

        .signal-text {
            font-size: 13px;
            color: #e0e0e0;
        }

        .trade-history {
            background: #1e2749;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            margin-bottom: 20px;
        }

        .history-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .history-table {
            width: 100%;
            border-collapse: collapse;
            background: #0a0e27;
            border-radius: 5px;
            overflow: hidden;
        }

        .history-table thead {
            background: #2a3250;
        }

        .history-table th {
            padding: 12px;
            text-align: left;
            font-size: 12px;
            color: #8899aa;
            text-transform: uppercase;
            font-weight: 600;
        }

        .history-table td {
            padding: 12px;
            border-top: 1px solid #1e2749;
            font-size: 13px;
            color: #e0e0e0;
        }

        .history-table-container {
            max-height: 400px;
            overflow-y: auto;
        }

        .result-win {
            color: #2ecc71;
            font-weight: 600;
        }

        .result-loss {
            color: #ff4757;
            font-weight: 600;
        }

        .activities-log {
            background: #1e2749;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .log-container {
            max-height: 300px;
            overflow-y: auto;
            background: #0a0e27;
            padding: 15px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
        }

        .log-entry {
            font-size: 12px;
            color: #8899aa;
            margin-bottom: 8px;
            line-height: 1.5;
        }

        .log-entry .timestamp {
            color: #00d4ff;
            margin-right: 10px;
        }

        .log-entry.error {
            color: #ff4757;
        }

        .log-entry.success {
            color: #2ecc71;
        }

        @media (max-width: 768px) {
            .main-grid {
                grid-template-columns: 1fr;
            }

            .header h1 {
                font-size: 22px;
                padding-right: 0;
                margin-top: 40px;
            }

            .connection-badge {
                top: 10px;
                right: 10px;
                font-size: 10px;
                padding: 6px 12px;
            }

            .markets-grid {
                grid-template-columns: 1fr;
            }

            .settings-grid {
                grid-template-columns: 1fr;
            }

            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .control-buttons {
                flex-direction: column;
            }

            .control-buttons .btn {
                width: 100%;
            }

            .history-table {
                font-size: 11px;
            }

            .history-table th,
            .history-table td {
                padding: 8px 5px;
            }
        }

        .timer-display {
            text-align: center;
            padding: 10px;
            background: rgba(0, 212, 255, 0.1);
            border-radius: 5px;
            margin-top: 10px;
        }

        .timer-label {
            font-size: 11px;
            color: #8899aa;
            text-transform: uppercase;
        }

        .timer-value {
            font-size: 20px;
            font-weight: 700;
            color: #00d4ff;
            margin-top: 5px;
            font-family: 'Courier New', monospace;
        }

        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <!-- Connection Badge -->
            <div class="connection-badge disconnected" id="connectionBadge">
                <div class="connection-badge-dot"></div>
                <span id="connectionStatus">Disconnected</span>
            </div>

            <h1>‚ö° BEN SNIPER - Deriv Trading Bot</h1>
            
            <div class="login-section" id="loginSection">
                <div class="login-input-group">
                    <input type="password" class="login-input" id="apiToken" placeholder="Enter Deriv API Token">
                    <button class="btn btn-primary" id="loginBtn">Login</button>
                </div>
            </div>

            <div class="account-info hidden" id="accountInfo">
                <div class="info-item">
                    <div class="info-label">Account Type</div>
                    <div class="info-value" id="accountType">-</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Currency</div>
                    <div class="info-value" id="accountCurrency">-</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Balance</div>
                    <div class="info-value" id="accountBalance">-</div>
                </div>
                <div class="info-item">
                    <button class="btn btn-danger" id="logoutBtn">Logout</button>
                </div>
            </div>

            <div class="timer-display hidden" id="timerDisplay">
                <div class="timer-label">Session Time</div>
                <div class="timer-value" id="timerValue">00:00:00</div>
            </div>
        </div>

        <div class="signal-monitor">
            <div class="monitor-header">
                <h2 class="panel-title">üìä Signal Monitor</h2>
                <div class="status-indicator">
                    <div class="pulse-dot" id="statusDot"></div>
                    <span class="status-text" id="statusText">Bot Inactive</span>
                </div>
            </div>
            <div class="signals-container" id="signalsContainer">
                <div class="signal-item">
                    <div class="signal-text">Waiting for bot activation...</div>
                </div>
            </div>
        </div>

        <div class="main-grid">
            <div class="panel">
                <h2 class="panel-title">üéØ Market Selection</h2>
                <div class="markets-grid" id="marketsGrid"></div>
            </div>

            <div class="panel">
                <h2 class="panel-title">üîß Filters</h2>
                <div class="filter-section">
                    <div class="filter-item">
                        <span class="filter-label">Trend Filter (50 EMA)</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="trendFilter">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="filter-item">
                        <span class="filter-label">Zero Closing Filter</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="zeroClosingFilter">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="filter-item">
                        <span class="filter-label">Ignore % (Opposite Wick)</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="ignoreWickPercent">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="filter-item">
                        <span class="filter-label">Ignore Height (Candle Height)</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="ignoreHeight">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="filter-item">
                        <span class="filter-label">Ignore Match Diff (Low/High Match)</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="ignoreMatchDiff">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="filter-item">
                        <span class="filter-label">Require Engulfing (Strict Breakout)</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="requireEngulfing">
                            <span class="slider"></span>
                        </label>
                    </div>
                </div>

                <h2 class="panel-title" style="margin-top: 20px;">‚öôÔ∏è Trade Settings</h2>
                <div class="settings-grid">
                    <div class="input-group">
                        <label class="input-label">Stake Amount</label>
                        <input type="number" class="input-field" id="stakeAmount" value="1" min="0.35" step="0.01">
                    </div>
                    <div class="input-group">
                        <label class="input-label">Stop Loss</label>
                        <input type="number" class="input-field" id="stopLoss" value="10" min="0" step="1">
                    </div>
                    <div class="input-group">
                        <label class="input-label">Take Profit</label>
                        <input type="number" class="input-field" id="takeProfit" value="20" min="0" step="1">
                    </div>
                    <div class="input-group">
                        <label class="input-label">Duration Type</label>
                        <select class="select-field" id="durationType">
                            <option value="t">Ticks</option>
                            <option value="s">Seconds</option>
                            <option value="m">Minutes</option>
                        </select>
                    </div>
                    <div class="input-group">
                        <label class="input-label">Duration Value</label>
                        <input type="number" class="input-field" id="durationValue" value="5" min="1" step="1">
                    </div>
                    <div class="input-group">
                        <label class="input-label">Min Lower Wick % (Buy)</label>
                        <input type="number" class="input-field" id="minLowerWickBuy" value="50" min="0" max="100" step="1">
                    </div>
                    <div class="input-group">
                        <label class="input-label">Min Upper Wick % (Sell)</label>
                        <input type="number" class="input-field" id="minUpperWickSell" value="50" min="0" max="100" step="1">
                    </div>
                </div>

                <div class="control-buttons">
                    <button class="btn btn-success" id="autoTradeBtn" disabled>Start Auto Trade</button>
                </div>
            </div>
        </div>

        <div class="panel">
            <h2 class="panel-title">üìà Trading Statistics</h2>
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-label">Total Trades</div>
                    <div class="stat-value" id="totalTrades">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Wins</div>
                    <div class="stat-value profit" id="totalWins">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Losses</div>
                    <div class="stat-value loss" id="totalLosses">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">P/L</div>
                    <div class="stat-value" id="profitLoss">0.00</div>
                </div>
            </div>
        </div>

        <div class="trade-history">
            <div class="history-header">
                <h2 class="panel-title">üìã Trade History</h2>
                <button class="btn btn-danger" id="clearHistoryBtn">Clear History</button>
            </div>
            <div class="history-table-container">
                <table class="history-table">
                    <thead>
                        <tr>
                            <th>S/N</th>
                            <th>Time</th>
                            <th>Market</th>
                            <th>Type</th>
                            <th>Stake</th>
                            <th>Result</th>
                        </tr>
                    </thead>
                    <tbody id="historyTableBody">
                        <tr>
                            <td colspan="6" style="text-align: center; color: #8899aa;">No trades yet</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="activities-log">
            <h2 class="panel-title">üìù Activity Log</h2>
            <div class="log-container" id="logContainer">
                <div class="log-entry">
                    <span class="timestamp">[--:--:--]</span> System initialized. Waiting for login...
                </div>
            </div>
        </div>
    </div>

    <script>
        // Market definitions
        const markets = {
            '1HZ10V': 'Volatility 10 (1s)',
            '1HZ25V': 'Volatility 25 (1s)',
            '1HZ50V': 'Volatility 50 (1s)',
            '1HZ75V': 'Volatility 75 (1s)',
            '1HZ100V': 'Volatility 100 (1s)',
            'R_10': 'Volatility 10',
            'R_25': 'Volatility 25',
            'R_50': 'Volatility 50',
            'R_75': 'Volatility 75',
            'R_100': 'Volatility 100',
            'stpRNG': 'Step Index 100',
            'stpRNG2': 'Step Index 200',
            'stpRNG3': 'Step Index 300',
            'stpRNG4': 'Step Index 400',
            'stpRNG5': 'Step Index 500'
        };

        // Global state
        let ws = null;
        let isLoggedIn = false;
        let isAutoTrading = false;
        let activeMarkets = {};
        let marketSubscriptions = {};
        let pendingSubscriptions = new Map();
        let marketSubscriptionStatus = {};
        let candleData = {};
        let tradeHistory = [];
        let sessionTimer = null;
        let sessionStartTime = null;
        let accountInfo = {};
        let tradeStats = {
            total: 0,
            wins: 0,
            losses: 0,
            profitLoss: 0
        };
        let pendingTrades = new Map();
        let isFirstSignal = true;
        let lastHeartbeat = Date.now();
        
        // One trade per candle per market tracking
        let tradedCandles = {};
        
        // Request ID tracking
        let requestIdCounter = 0;
        let pendingProposals = new Map();
        let buyRequestMap = new Map();

        // Bot activation tracking
        let botStartTime = null;
        let initializedMarkets = new Set();

        // Initialize markets
        Object.keys(markets).forEach(symbol => {
            activeMarkets[symbol] = true;
            candleData[symbol] = [];
            tradedCandles[symbol] = new Set();
            marketSubscriptionStatus[symbol] = 'inactive';
        });

        // Update market status dot
        function updateMarketStatusDot(symbol, status) {
            const dot = document.getElementById(`status-dot-${symbol}`);
            if (dot) {
                dot.className = 'market-status-dot';
                if (status === 'subscribed') {
                    dot.classList.add('subscribed');
                } else if (status === 'failed') {
                    dot.classList.add('failed');
                } else if (status === 'subscribing') {
                    dot.classList.add('subscribing');
                }
                marketSubscriptionStatus[symbol] = status;
            }
        }

        // Update connection badge
        function updateConnectionBadge(connected) {
            const badge = document.getElementById('connectionBadge');
            const status = document.getElementById('connectionStatus');
            
            if (connected) {
                badge.className = 'connection-badge connected';
                status.textContent = 'Connected';
            } else {
                badge.className = 'connection-badge disconnected';
                status.textContent = 'Disconnected';
            }
        }

        // Load saved settings
        function loadSettings() {
            const savedToken = sessionStorage.getItem('derivToken');
            const savedMarkets = sessionStorage.getItem('activeMarkets');
            const savedTrendFilter = sessionStorage.getItem('trendFilter');
            const savedZeroFilter = sessionStorage.getItem('zeroClosingFilter');
            const savedIgnoreWickPercent = sessionStorage.getItem('ignoreWickPercent');
            const savedIgnoreHeight = sessionStorage.getItem('ignoreHeight');
            const savedIgnoreMatchDiff = sessionStorage.getItem('ignoreMatchDiff');
            const savedRequireEngulfing = sessionStorage.getItem('requireEngulfing');
            const savedStake = sessionStorage.getItem('stakeAmount');
            const savedStopLoss = sessionStorage.getItem('stopLoss');
            const savedTakeProfit = sessionStorage.getItem('takeProfit');
            const savedDurationType = sessionStorage.getItem('durationType');
            const savedDurationValue = sessionStorage.getItem('durationValue');
            const savedMinLowerWickBuy = sessionStorage.getItem('minLowerWickBuy');
            const savedMinUpperWickSell = sessionStorage.getItem('minUpperWickSell');
            const savedTradeHistory = sessionStorage.getItem('tradeHistory');
            const savedStats = sessionStorage.getItem('tradeStats');

            if (savedToken) {
                document.getElementById('apiToken').value = savedToken;
            }

            if (savedMarkets) {
                activeMarkets = JSON.parse(savedMarkets);
            }

            if (savedTrendFilter) {
                document.getElementById('trendFilter').checked = savedTrendFilter === 'true';
            }

            if (savedZeroFilter) {
                document.getElementById('zeroClosingFilter').checked = savedZeroFilter === 'true';
            }

            if (savedIgnoreWickPercent) {
                document.getElementById('ignoreWickPercent').checked = savedIgnoreWickPercent === 'true';
            }

            if (savedIgnoreHeight) {
                document.getElementById('ignoreHeight').checked = savedIgnoreHeight === 'true';
            }

            if (savedIgnoreMatchDiff) {
                document.getElementById('ignoreMatchDiff').checked = savedIgnoreMatchDiff === 'true';
            }

            if (savedRequireEngulfing) {
                document.getElementById('requireEngulfing').checked = savedRequireEngulfing === 'true';
            }

            if (savedStake) {
                document.getElementById('stakeAmount').value = savedStake;
            }

            if (savedStopLoss) {
                document.getElementById('stopLoss').value = savedStopLoss;
            }

            if (savedTakeProfit) {
                document.getElementById('takeProfit').value = savedTakeProfit;
            }

            if (savedDurationType) {
                document.getElementById('durationType').value = savedDurationType;
            }

            if (savedDurationValue) {
                document.getElementById('durationValue').value = savedDurationValue;
            }

            if (savedMinLowerWickBuy) {
                document.getElementById('minLowerWickBuy').value = savedMinLowerWickBuy;
            }

            if (savedMinUpperWickSell) {
                document.getElementById('minUpperWickSell').value = savedMinUpperWickSell;
            }

            if (savedTradeHistory) {
                tradeHistory = JSON.parse(savedTradeHistory);
                updateTradeHistoryTable();
            }

            if (savedStats) {
                tradeStats = JSON.parse(savedStats);
                updateStats();
            }
        }

        // Save settings
        function saveSettings() {
            sessionStorage.setItem('derivToken', document.getElementById('apiToken').value);
            sessionStorage.setItem('activeMarkets', JSON.stringify(activeMarkets));
            sessionStorage.setItem('trendFilter', document.getElementById('trendFilter').checked);
            sessionStorage.setItem('zeroClosingFilter', document.getElementById('zeroClosingFilter').checked);
            sessionStorage.setItem('ignoreWickPercent', document.getElementById('ignoreWickPercent').checked);
            sessionStorage.setItem('ignoreHeight', document.getElementById('ignoreHeight').checked);
            sessionStorage.setItem('ignoreMatchDiff', document.getElementById('ignoreMatchDiff').checked);
            sessionStorage.setItem('requireEngulfing', document.getElementById('requireEngulfing').checked);
            sessionStorage.setItem('stakeAmount', document.getElementById('stakeAmount').value);
            sessionStorage.setItem('stopLoss', document.getElementById('stopLoss').value);
            sessionStorage.setItem('takeProfit', document.getElementById('takeProfit').value);
            sessionStorage.setItem('durationType', document.getElementById('durationType').value);
            sessionStorage.setItem('durationValue', document.getElementById('durationValue').value);
            sessionStorage.setItem('minLowerWickBuy', document.getElementById('minLowerWickBuy').value);
            sessionStorage.setItem('minUpperWickSell', document.getElementById('minUpperWickSell').value);
            sessionStorage.setItem('tradeHistory', JSON.stringify(tradeHistory));
            sessionStorage.setItem('tradeStats', JSON.stringify(tradeStats));
        }

        // Render markets with status dots
        function renderMarkets() {
            const grid = document.getElementById('marketsGrid');
            grid.innerHTML = '';

            Object.entries(markets).forEach(([symbol, name]) => {
                const div = document.createElement('div');
                div.className = 'market-item';
                div.innerHTML = `
                    <div class="market-left">
                        <div class="market-status-dot" id="status-dot-${symbol}"></div>
                        <span class="market-name">${name}</span>
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" ${activeMarkets[symbol] ? 'checked' : ''} data-symbol="${symbol}">
                        <span class="slider"></span>
                    </label>
                `;
                grid.appendChild(div);

                const toggle = div.querySelector('input');
                toggle.addEventListener('change', (e) => {
                    activeMarkets[symbol] = e.target.checked;
                    logActivity(`Market ${name} ${e.target.checked ? 'enabled' : 'disabled'}`);
                    saveSettings();
                    
                    if (isLoggedIn && isAutoTrading) {
                        if (e.target.checked) {
                            subscribeToMarket(symbol);
                        } else {
                            unsubscribeFromMarket(symbol);
                        }
                    } else if (!e.target.checked) {
                        updateMarketStatusDot(symbol, 'inactive');
                    }
                });
            });
        }

        // Log activity
        function logActivity(message, type = 'info') {
            const container = document.getElementById('logContainer');
            const time = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.innerHTML = `<span class="timestamp">[${time}]</span> ${message}`;
            container.insertBefore(entry, container.firstChild);
            
            while (container.children.length > 100) {
                container.removeChild(container.lastChild);
            }
        }

        // Connect to Deriv API
        function connectWebSocket(token) {
            return new Promise((resolve, reject) => {
                ws = new WebSocket('wss://ws.derivws.com/websockets/v3?app_id=1089');

                ws.onopen = () => {
                    logActivity('WebSocket connected', 'success');
                    updateConnectionBadge(true);
                    lastHeartbeat = Date.now();
                    ws.send(JSON.stringify({ authorize: token }));
                };

                ws.onmessage = (msg) => {
                    lastHeartbeat = Date.now();
                    const data = JSON.parse(msg.data);
                    handleWebSocketMessage(data, resolve, reject);
                };

                ws.onerror = (error) => {
                    logActivity('WebSocket error: ' + error.message, 'error');
                    updateConnectionBadge(false);
                    reject(error);
                };

                ws.onclose = () => {
                    logActivity('WebSocket disconnected', 'error');
                    updateConnectionBadge(false);
                    
                    Object.keys(markets).forEach(symbol => {
                        updateMarketStatusDot(symbol, 'inactive');
                    });
                    
                    stopSessionTimer();
                    
                    if (isLoggedIn) {
                        setTimeout(() => {
                            logActivity('Attempting to reconnect...', 'info');
                            const savedToken = sessionStorage.getItem('derivToken');
                            if (savedToken) {
                                connectWebSocket(savedToken)
                                    .then(() => {
                                        logActivity('Reconnected successfully', 'success');
                                        startSessionTimer();
                                        if (isAutoTrading) {
                                            subscribeToActiveMarkets();
                                        }
                                    })
                                    .catch(err => {
                                        logActivity('Reconnection failed: ' + err.message, 'error');
                                    });
                            }
                        }, 3000);
                    }
                };
            });
        }

        // Handle WebSocket messages
        function handleWebSocketMessage(data, resolve, reject) {
            if (data.error) {
                if (data.error.code !== 'AlreadySubscribed') {
                    logActivity('API Error: ' + data.error.message, 'error');
                    
                    if (data.echo_req && data.echo_req.ticks_history) {
                        const symbol = data.echo_req.ticks_history;
                        if (pendingSubscriptions.has(symbol)) {
                            pendingSubscriptions.delete(symbol);
                            updateMarketStatusDot(symbol, 'failed');
                            logActivity(`Subscription failed for ${markets[symbol]}: ${data.error.message}`, 'error');
                        }
                    }
                }
                if (reject && data.error.code !== 'AlreadySubscribed') {
                    reject(new Error(data.error.message));
                }
                return;
            }

            if (data.msg_type === 'authorize') {
                accountInfo = {
                    type: data.authorize.account_list.find(a => a.loginid === data.authorize.loginid)?.is_virtual ? 'Demo' : 'Real',
                    currency: data.authorize.currency,
                    balance: data.authorize.balance,
                    loginid: data.authorize.loginid
                };

                document.getElementById('accountType').textContent = accountInfo.type;
                document.getElementById('accountCurrency').textContent = accountInfo.currency;
                document.getElementById('accountBalance').textContent = parseFloat(accountInfo.balance).toFixed(2);

                logActivity(`Logged in as ${accountInfo.loginid} (${accountInfo.type})`, 'success');
                
                ws.send(JSON.stringify({ balance: 1, subscribe: 1 }));

                if (resolve) resolve();
            }

            if (data.msg_type === 'balance') {
                accountInfo.balance = data.balance.balance;
                document.getElementById('accountBalance').textContent = parseFloat(accountInfo.balance).toFixed(2);
            }

            if (data.msg_type === 'candles' && data.candles) {
                let symbol = null;
                
                if (data.echo_req && data.echo_req.ticks_history) {
                    symbol = data.echo_req.ticks_history;
                }
                
                if (symbol && pendingSubscriptions.has(symbol)) {
                    pendingSubscriptions.delete(symbol);
                    marketSubscriptions[symbol] = data.subscription.id;
                    processCandles(symbol, data.candles);
                    updateMarketStatusDot(symbol, 'subscribed');
                    logActivity(`‚úì ${markets[symbol]} subscribed successfully`, 'success');
                } else if (symbol && marketSubscriptions[symbol]) {
                    processCandles(symbol, data.candles);
                }
            }

            if (data.msg_type === 'ohlc' && data.ohlc) {
                let symbol = null;
                
                if (data.echo_req && data.echo_req.ticks_history) {
                    symbol = data.echo_req.ticks_history;
                } else if (data.subscription && data.subscription.id) {
                    symbol = findSymbolBySubscriptionId(data.subscription.id);
                }
                
                if (symbol) {
                    updateCandle(symbol, data.ohlc);
                }
            }

            if (data.msg_type === 'proposal' && data.proposal) {
                const reqId = data.req_id;
                if (pendingProposals.has(reqId)) {
                    const proposalData = pendingProposals.get(reqId);
                    proposalData.resolve(data);
                    pendingProposals.delete(reqId);
                }
            }

            if (data.msg_type === 'buy') {
                if (data.buy.contract_id) {
                    const reqId = data.req_id;
                    
                    if (buyRequestMap.has(reqId)) {
                        const tradeContext = buyRequestMap.get(reqId);
                        
                        pendingTrades.set(data.buy.contract_id, {
                            symbol: tradeContext.symbol,
                            type: tradeContext.type,
                            stake: tradeContext.stake,
                            candle_time: tradeContext.candleKey
                        });
                        
                        buyRequestMap.delete(reqId);
                        
                        ws.send(JSON.stringify({
                            proposal_open_contract: 1,
                            contract_id: data.buy.contract_id,
                            subscribe: 1
                        }));
                        
                        logActivity(`Trade opened: Contract ID ${data.buy.contract_id}`, 'success');
                    }
                }
            }

            if (data.msg_type === 'proposal_open_contract') {
                handleTradeResult(data.proposal_open_contract);
            }

            if (data.msg_type === 'forget') {
                if (data.forget) {
                    logActivity(`Unsubscribed from subscription ID: ${data.forget}`, 'info');
                }
            }

            if (data.msg_type === 'ping') {
                ws.send(JSON.stringify({ ping: 1 }));
            }
        }

        // Find symbol by subscription ID
        function findSymbolBySubscriptionId(id) {
            for (const [symbol, subId] of Object.entries(marketSubscriptions)) {
                if (subId === id) {
                    return symbol;
                }
            }
            return null;
        }

        // Login
        document.getElementById('loginBtn').addEventListener('click', async () => {
            const token = document.getElementById('apiToken').value.trim();
            if (!token) {
                logActivity('Please enter API token', 'error');
                return;
            }

            const loginBtn = document.getElementById('loginBtn');
            loginBtn.disabled = true;
            loginBtn.textContent = 'Connecting...';

            try {
                await connectWebSocket(token);
                isLoggedIn = true;
                
                document.getElementById('loginSection').classList.add('hidden');
                document.getElementById('accountInfo').classList.remove('hidden');
                document.getElementById('timerDisplay').classList.remove('hidden');
                document.getElementById('autoTradeBtn').disabled = false;

                saveSettings();
                startSessionTimer();
                logActivity('Login successful', 'success');
            } catch (error) {
                logActivity('Login failed: ' + error.message, 'error');
                loginBtn.disabled = false;
                loginBtn.textContent = 'Login';
                updateConnectionBadge(false);
            }
        });

        // Logout
        document.getElementById('logoutBtn').addEventListener('click', () => {
            if (isAutoTrading) {
                stopAutoTrading();
            }

            if (ws) {
                ws.close();
                ws = null;
            }

            isLoggedIn = false;
            stopSessionTimer();
            updateConnectionBadge(false);

            Object.keys(markets).forEach(symbol => {
                updateMarketStatusDot(symbol, 'inactive');
            });

            marketSubscriptions = {};
            pendingSubscriptions.clear();
            initializedMarkets.clear();
            botStartTime = null;

            document.getElementById('apiToken').value = '';
            sessionStorage.removeItem('derivToken');

            document.getElementById('loginSection').classList.remove('hidden');
            document.getElementById('accountInfo').classList.add('hidden');
            document.getElementById('timerDisplay').classList.add('hidden');
            document.getElementById('autoTradeBtn').disabled = true;

            const loginBtn = document.getElementById('loginBtn');
            loginBtn.disabled = false;
            loginBtn.textContent = 'Login';

            logActivity('Logged out successfully - Token cleared', 'success');
        });

        // Session timer
        function startSessionTimer() {
            sessionStartTime = Date.now();
            sessionTimer = setInterval(() => {
                const elapsed = Date.now() - sessionStartTime;
                const hours = Math.floor(elapsed / 3600000);
                const minutes = Math.floor((elapsed % 3600000) / 60000);
                const seconds = Math.floor((elapsed % 60000) / 1000);
                
                document.getElementById('timerValue').textContent = 
                    `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            }, 1000);
        }

        function stopSessionTimer() {
            if (sessionTimer) {
                clearInterval(sessionTimer);
                sessionTimer = null;
            }
            document.getElementById('timerValue').textContent = '00:00:00';
        }

        // Subscribe to market
        function subscribeToMarket(symbol) {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                logActivity('Cannot subscribe: WebSocket not connected', 'error');
                return;
            }

            if (marketSubscriptions[symbol]) {
                logActivity(`Already monitoring ${markets[symbol]}`, 'info');
                updateMarketStatusDot(symbol, 'subscribed');
                return;
            }

            updateMarketStatusDot(symbol, 'subscribing');
            pendingSubscriptions.set(symbol, Date.now());

            const subscribeMsg = {
                ticks_history: symbol,
                adjust_start_time: 1,
                count: 100,
                end: 'latest',
                start: 1,
                style: 'candles',
                granularity: 60,
                subscribe: 1
            };

            ws.send(JSON.stringify(subscribeMsg));
            logActivity(`Subscribing to ${markets[symbol]}...`);

            setTimeout(() => {
                if (pendingSubscriptions.has(symbol) && !marketSubscriptions[symbol]) {
                    pendingSubscriptions.delete(symbol);
                    updateMarketStatusDot(symbol, 'failed');
                    logActivity(`Subscription timeout for ${markets[symbol]}`, 'error');
                }
            }, 10000);
        }

        function unsubscribeFromMarket(symbol) {
            if (!ws || ws.readyState !== WebSocket.OPEN) return;

            if (marketSubscriptions[symbol]) {
                ws.send(JSON.stringify({ forget: marketSubscriptions[symbol] }));
                delete marketSubscriptions[symbol];
                candleData[symbol] = [];
                tradedCandles[symbol].clear();
                initializedMarkets.delete(symbol);
                updateMarketStatusDot(symbol, 'inactive');
                logActivity(`Unsubscribed from ${markets[symbol]}`);
            }
        }

        // Subscribe to all active markets
        function subscribeToActiveMarkets() {
            Object.keys(activeMarkets).forEach(symbol => {
                if (activeMarkets[symbol]) {
                    subscribeToMarket(symbol);
                }
            });
        }

        // Unsubscribe from all markets
        function unsubscribeFromAllMarkets() {
            Object.keys(marketSubscriptions).forEach(symbol => {
                unsubscribeFromMarket(symbol);
            });
        }

        // Process candles
        function processCandles(symbol, candles) {
            candleData[symbol] = candles.map(c => ({
                time: c.epoch,
                open: parseFloat(c.open),
                high: parseFloat(c.high),
                low: parseFloat(c.low),
                close: parseFloat(c.close)
            }));
            
            // Mark this market as initialized
            initializedMarkets.add(symbol);
            
            logActivity(`Loaded ${candles.length} candles for ${markets[symbol]} - Ready for signals`, 'success');
        }

        // Update candle
        function updateCandle(symbol, ohlc) {
            if (!candleData[symbol]) candleData[symbol] = [];

            const newCandle = {
                time: ohlc.epoch,
                open: parseFloat(ohlc.open),
                high: parseFloat(ohlc.high),
                low: parseFloat(ohlc.low),
                close: parseFloat(ohlc.close)
            };

            const lastCandle = candleData[symbol][candleData[symbol].length - 1];
            
            if (lastCandle && lastCandle.time === newCandle.time) {
                // Update the current (ongoing) candle
                candleData[symbol][candleData[symbol].length - 1] = newCandle;

                // ONLY check for signals when the current candle updates (live ticks)
                if (isAutoTrading && 
                    initializedMarkets.has(symbol) && 
                    candleData[symbol].length >= 52) {
                    
                    checkForSignals(symbol);
                }
            } else {
                // NEW CANDLE STARTED - just add it, NO signal check here
                candleData[symbol].push(newCandle);
                if (candleData[symbol].length > 100) {
                    candleData[symbol].shift();
                }
            }
        }

        // Calculate EMA
        function calculateEMA(data, period) {
            if (data.length < period) return null;

            const k = 2 / (period + 1);
            let ema = data.slice(0, period).reduce((sum, candle) => sum + candle.close, 0) / period;

            for (let i = period; i < data.length; i++) {
                ema = data[i].close * k + ema * (1 - k);
            }

            return ema;
        }

        // Check for trading signals
        function checkForSignals(symbol) {
            if (candleData[symbol].length < 52) return;

            const candles = candleData[symbol];
            const lastCandle = candles[candles.length - 2];
            const prevCandle = candles[candles.length - 3];

            if (!lastCandle || !prevCandle) return;

            const candleKey = `${lastCandle.time}`;
            if (tradedCandles[symbol].has(candleKey)) {
                return;
            }

            // Get all filter states
            const trendFilter = document.getElementById('trendFilter').checked;
            const zeroClosingFilter = document.getElementById('zeroClosingFilter').checked;
            const ignoreWickPercent = document.getElementById('ignoreWickPercent').checked;
            const ignoreHeight = document.getElementById('ignoreHeight').checked;
            const ignoreMatchDiff = document.getElementById('ignoreMatchDiff').checked;
            const requireEngulfing = document.getElementById('requireEngulfing').checked;

            const minLowerWickBuy = parseFloat(document.getElementById('minLowerWickBuy').value) / 100;
            const minUpperWickSell = parseFloat(document.getElementById('minUpperWickSell').value) / 100;

            let ema50 = null;
            if (trendFilter) {
                ema50 = calculateEMA(candles.slice(0, -1), 50);
            }

            const buySignal = checkTweezersBottom(prevCandle, lastCandle, zeroClosingFilter, minLowerWickBuy, ignoreWickPercent, ignoreHeight, ignoreMatchDiff, requireEngulfing);
            
            if (buySignal) {
                if (trendFilter && ema50) {
                    if (lastCandle.close > ema50) {
                        addSignal(symbol, 'Tweezers Bottom BUY', 'buy');
                        executeTrade(symbol, 'CALL', candleKey);
                    }
                } else {
                    addSignal(symbol, 'Tweezers Bottom BUY', 'buy');
                    executeTrade(symbol, 'CALL', candleKey);
                }
            }

            const sellSignal = checkTweezersTop(prevCandle, lastCandle, zeroClosingFilter, minUpperWickSell, ignoreWickPercent, ignoreHeight, ignoreMatchDiff, requireEngulfing);
            
            if (sellSignal) {
                if (trendFilter && ema50) {
                    if (lastCandle.close < ema50) {
                        addSignal(symbol, 'Tweezers Top SELL', 'sell');
                        executeTrade(symbol, 'PUT', candleKey);
                    }
                } else {
                    addSignal(symbol, 'Tweezers Top SELL', 'sell');
                    executeTrade(symbol, 'PUT', candleKey);
                }
            }
        }

        // FIXED: Check Tweezers Bottom pattern
        function checkTweezersBottom(candle1, candle2, zeroClosing, minWickPercent, ignoreWickPercent, ignoreHeight, ignoreMatchDiff, requireEngulfing) {
            // 1. Candle 1 must be RED
            const isCandle1Red = candle1.close < candle1.open;
            if (!isCandle1Red) return false;

            const candle1Range = candle1.high - candle1.low;
            if (candle1Range === 0) return false;

            const candle1LowerWick = Math.min(candle1.open, candle1.close) - candle1.low;
            
            // 2. CHECK WICK % on the First Candle ONLY (The Signal Candle)
            if (candle1LowerWick / candle1Range < minWickPercent) return false;

            // 3. Zero Closing Filter (Optional Strict Mode)
            if (zeroClosing) {
                const candle1UpperWick = candle1.high - Math.max(candle1.open, candle1.close);
                if (candle1UpperWick / candle1Range > 0.01) return false; // Must be shaven top
            }

            // 4. Candle 2 must be GREEN
            const isCandle2Green = candle2.close > candle2.open;
            if (!isCandle2Green) return false;
            
            // 5. Check Matching Lows (Unless Ignored)
            if (!ignoreMatchDiff) {
                const lowDiff = Math.abs(candle1.low - candle2.low);
                // Use a dynamic tolerance based on price (0.01%) instead of hardcoded 0.003
                if (lowDiff / candle1.low > 0.0001 && lowDiff > 0.05) return false; 
            }

            // 6. Height Check (If NOT ignored, enforce strict engulfing size)
            // If Ignore Height is ON, we skip this check entirely.
            if (!ignoreHeight) {
                const candle1Body = Math.abs(candle1.close - candle1.open);
                const candle2Body = Math.abs(candle2.close - candle2.open);
                if (candle2Body < candle1Body * 0.5) return false;
            }

            // 7. Strict Engulfing Toggle
            if (requireEngulfing) {
                if (candle2.close < candle1.high) return false;
            }

            return true;
        }

        // FIXED: Check Tweezers Top pattern
        function checkTweezersTop(candle1, candle2, zeroClosing, minWickPercent, ignoreWickPercent, ignoreHeight, ignoreMatchDiff, requireEngulfing) {
            // 1. Candle 1 must be GREEN
            const isCandle1Green = candle1.close > candle1.open;
            if (!isCandle1Green) return false;

            const candle1Range = candle1.high - candle1.low;
            if (candle1Range === 0) return false;

            const candle1UpperWick = candle1.high - Math.max(candle1.open, candle1.close);

            // 2. CHECK WICK % on the First Candle ONLY
            if (candle1UpperWick / candle1Range < minWickPercent) return false;

            // 3. Zero Closing Filter
            if (zeroClosing) {
                const candle1LowerWick = Math.min(candle1.open, candle1.close) - candle1.low;
                if (candle1LowerWick / candle1Range > 0.01) return false; // Must be shaven bottom
            }

            // 4. Candle 2 must be RED
            const isCandle2Red = candle2.close < candle2.open;
            if (!isCandle2Red) return false;

            // 5. Check Matching Highs (Unless Ignored)
            if (!ignoreMatchDiff) {
                const highDiff = Math.abs(candle1.high - candle2.high);
                if (highDiff / candle1.high > 0.0001 && highDiff > 0.05) return false;
            }

            // 6. Height Check
            if (!ignoreHeight) {
                const candle1Body = Math.abs(candle1.close - candle1.open);
                const candle2Body = Math.abs(candle2.close - candle2.open);
                if (candle2Body < candle1Body * 0.5) return false;
            }

            // 7. Strict Engulfing Toggle
            if (requireEngulfing) {
                if (candle2.close > candle1.low) return false;
            }

            return true;
        }

        // Add signal to monitor
        let signalCounter = 0;
        function addSignal(symbol, pattern, signalType) {
            const container = document.getElementById('signalsContainer');
            
            if (isFirstSignal) {
                container.innerHTML = '';
                isFirstSignal = false;
            }

            const signalId = `signal-${signalCounter++}`;
            
            const time = new Date().toLocaleTimeString();
            const signalDiv = document.createElement('div');
            signalDiv.className = `signal-item ${signalType}`;
            signalDiv.id = signalId;
            signalDiv.innerHTML = `<div class="signal-text">[${time}] ${markets[symbol]} - ${pattern}</div>`;
            
            container.insertBefore(signalDiv, container.firstChild);
            
            while (container.children.length > 50) {
                container.removeChild(container.lastChild);
            }

            return signalId;
        }

        // Execute trade
        async function executeTrade(symbol, type, candleKey) {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                logActivity('Cannot execute trade: WebSocket not connected', 'error');
                return;
            }

            const stake = parseFloat(document.getElementById('stakeAmount').value);
            const durationType = document.getElementById('durationType').value;
            const durationValue = parseInt(document.getElementById('durationValue').value);

            const proposalReqId = ++requestIdCounter;

            const proposal = {
                proposal: 1,
                amount: stake,
                basis: 'stake',
                contract_type: type,
                currency: accountInfo.currency,
                duration: durationValue,
                duration_unit: durationType,
                symbol: symbol,
                req_id: proposalReqId
            };

            try {
                ws.send(JSON.stringify(proposal));
                
                const proposalResponse = await new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => {
                        pendingProposals.delete(proposalReqId);
                        reject(new Error('Proposal timeout'));
                    }, 5000);
                    
                    pendingProposals.set(proposalReqId, { resolve, reject, timeout });
                });

                if (pendingProposals.has(proposalReqId)) {
                    clearTimeout(pendingProposals.get(proposalReqId).timeout);
                    pendingProposals.delete(proposalReqId);
                }

                if (proposalResponse.proposal) {
                    const buyReqId = ++requestIdCounter;
                    
                    buyRequestMap.set(buyReqId, {
                        symbol: symbol,
                        type: type,
                        stake: stake,
                        candleKey: candleKey
                    });
                    
                    ws.send(JSON.stringify({
                        buy: proposalResponse.proposal.id,
                        price: stake,
                        req_id: buyReqId
                    }));

                    tradedCandles[symbol].add(candleKey);

                    logActivity(`Trade executed: ${type} on ${markets[symbol]} - Stake: ${stake}`, 'success');
                }
            } catch (error) {
                logActivity(`Trade execution failed: ${error.message}`, 'error');
            }
        }

        // Handle trade result
        function handleTradeResult(contract) {
            if (contract.status === 'sold' || contract.status === 'won' || contract.status === 'lost') {
                const profit = parseFloat(contract.profit || 0);
                const isWin = profit > 0;

                tradeStats.total++;
                if (isWin) {
                    tradeStats.wins++;
                } else {
                    tradeStats.losses++;
                }
                tradeStats.profitLoss += profit;

                const trade = {
                    time: new Date().toLocaleTimeString(),
                    market: markets[contract.underlying] || contract.underlying,
                    type: contract.contract_type,
                    stake: parseFloat(contract.buy_price || 0).toFixed(2),
                    result: profit.toFixed(2),
                    isWin: isWin
                };

                tradeHistory.unshift(trade);
                if (tradeHistory.length > 100) {
                    tradeHistory.pop();
                }

                updateStats();
                updateTradeHistoryTable();
                saveSettings();

                logActivity(`Trade closed: ${trade.market} - ${trade.type} - P/L: ${trade.result}`, isWin ? 'success' : 'error');

                const stopLoss = parseFloat(document.getElementById('stopLoss').value);
                const takeProfit = parseFloat(document.getElementById('takeProfit').value);

                if (stopLoss > 0 && Math.abs(tradeStats.profitLoss) >= stopLoss && tradeStats.profitLoss < 0) {
                    logActivity(`Stop loss reached: ${tradeStats.profitLoss.toFixed(2)}`, 'error');
                    stopAutoTrading();
                }

                if (takeProfit > 0 && tradeStats.profitLoss >= takeProfit) {
                    logActivity(`Take profit reached: ${tradeStats.profitLoss.toFixed(2)}`, 'success');
                    stopAutoTrading();
                }

                if (pendingTrades.has(contract.contract_id)) {
                    pendingTrades.delete(contract.contract_id);
                }
            }
        }

        // Update statistics
        function updateStats() {
            document.getElementById('totalTrades').textContent = tradeStats.total;
            document.getElementById('totalWins').textContent = tradeStats.wins;
            document.getElementById('totalLosses').textContent = tradeStats.losses;
            
            const plElement = document.getElementById('profitLoss');
            plElement.textContent = tradeStats.profitLoss.toFixed(2);
            plElement.className = 'stat-value ' + (tradeStats.profitLoss >= 0 ? 'profit' : 'loss');
        }

        // Update trade history table
        function updateTradeHistoryTable() {
            const tbody = document.getElementById('historyTableBody');
            
            if (tradeHistory.length === 0) {
                tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; color: #8899aa;">No trades yet</td></tr>';
                return;
            }

            tbody.innerHTML = '';
            tradeHistory.slice(0, 10).forEach((trade, index) => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${index + 1}</td>
                    <td>${trade.time}</td>
                    <td>${trade.market}</td>
                    <td>${trade.type}</td>
                    <td>${trade.stake}</td>
                    <td class="${trade.isWin ? 'result-win' : 'result-loss'}">${trade.result}</td>
                `;
                tbody.appendChild(row);
            });
        }

        // Start auto trading
        function startAutoTrading() {
            if (!isLoggedIn) {
                logActivity('Please login first', 'error');
                return;
            }

            isAutoTrading = true;
            isFirstSignal = true;
            botStartTime = Date.now();
            initializedMarkets.clear();
            
            Object.keys(tradedCandles).forEach(symbol => {
                tradedCandles[symbol].clear();
            });
            
            document.getElementById('autoTradeBtn').textContent = 'Stop Auto Trade';
            document.getElementById('autoTradeBtn').className = 'btn btn-danger';
            
            const statusText = document.getElementById('statusText');
            const statusDot = document.getElementById('statusDot');
            statusText.textContent = 'Bot Active - Analyzing Markets';
            statusText.className = 'status-text active';
            statusDot.className = 'pulse-dot active';

            const container = document.getElementById('signalsContainer');
            container.innerHTML = '<div class="signal-item"><div class="signal-text">Bot activated. Loading market data and waiting for fresh candles...</div></div>';

            logActivity('Auto trading started - Waiting for fresh candles before trading', 'success');

            subscribeToActiveMarkets();
        }

        // Stop auto trading
        function stopAutoTrading() {
            isAutoTrading = false;
            botStartTime = null;
            document.getElementById('autoTradeBtn').textContent = 'Start Auto Trade';
            document.getElementById('autoTradeBtn').className = 'btn btn-success';
            
            const statusText = document.getElementById('statusText');
            const statusDot = document.getElementById('statusDot');
            statusText.textContent = 'Bot Inactive';
            statusText.className = 'status-text';
            statusDot.className = 'pulse-dot';

            logActivity('Auto trading stopped', 'error');

            unsubscribeFromAllMarkets();

            const container = document.getElementById('signalsContainer');
            container.innerHTML = '<div class="signal-item"><div class="signal-text">Waiting for bot activation...</div></div>';
        }

        // Auto trade button
        document.getElementById('autoTradeBtn').addEventListener('click', () => {
            if (isAutoTrading) {
                stopAutoTrading();
            } else {
                startAutoTrading();
            }
        });

        // Clear history button
        document.getElementById('clearHistoryBtn').addEventListener('click', () => {
            if (confirm('Are you sure you want to clear trade history?')) {
                tradeHistory = [];
                tradeStats = { total: 0, wins: 0, losses: 0, profitLoss: 0 };
                updateStats();
                updateTradeHistoryTable();
                saveSettings();
                logActivity('Trade history cleared', 'success');
            }
        });

        // Save settings on change
        document.getElementById('trendFilter').addEventListener('change', () => {
            logActivity(`Trend filter ${document.getElementById('trendFilter').checked ? 'enabled' : 'disabled'}`);
            saveSettings();
        });

        document.getElementById('zeroClosingFilter').addEventListener('change', () => {
            logActivity(`Zero closing filter ${document.getElementById('zeroClosingFilter').checked ? 'enabled' : 'disabled'}`);
            saveSettings();
        });

        document.getElementById('ignoreWickPercent').addEventListener('change', () => {
            logActivity(`Ignore % filter ${document.getElementById('ignoreWickPercent').checked ? 'enabled' : 'disabled'}`);
            saveSettings();
        });

        document.getElementById('ignoreHeight').addEventListener('change', () => {
            logActivity(`Ignore height filter ${document.getElementById('ignoreHeight').checked ? 'enabled' : 'disabled'}`);
            saveSettings();
        });

        document.getElementById('ignoreMatchDiff').addEventListener('change', () => {
            logActivity(`Ignore match diff filter ${document.getElementById('ignoreMatchDiff').checked ? 'enabled' : 'disabled'}`);
            saveSettings();
        });

        document.getElementById('requireEngulfing').addEventListener('change', () => {
            logActivity(`Require Engulfing filter ${document.getElementById('requireEngulfing').checked ? 'enabled' : 'disabled'}`);
            saveSettings();
        });

        document.getElementById('stakeAmount').addEventListener('change', () => {
            logActivity(`Stake amount updated to ${document.getElementById('stakeAmount').value}`);
            saveSettings();
        });

        document.getElementById('stopLoss').addEventListener('change', () => {
            logActivity(`Stop loss updated to ${document.getElementById('stopLoss').value}`);
            saveSettings();
        });

        document.getElementById('takeProfit').addEventListener('change', () => {
            logActivity(`Take profit updated to ${document.getElementById('takeProfit').value}`);
            saveSettings();
        });

        document.getElementById('durationType').addEventListener('change', () => {
            logActivity(`Duration type updated to ${document.getElementById('durationType').value}`);
            saveSettings();
        });

        document.getElementById('durationValue').addEventListener('change', () => {
            logActivity(`Duration value updated to ${document.getElementById('durationValue').value}`);
            saveSettings();
        });

        document.getElementById('minLowerWickBuy').addEventListener('change', () => {
            logActivity(`Min lower wick (Buy) updated to ${document.getElementById('minLowerWickBuy').value}%`);
            saveSettings();
        });

        document.getElementById('minUpperWickSell').addEventListener('change', () => {
            logActivity(`Min upper wick (Sell) updated to ${document.getElementById('minUpperWickSell').value}%`);
            saveSettings();
        });

        // Validate input fields
        function validateInputs() {
            const stakeAmount = parseFloat(document.getElementById('stakeAmount').value);
            const stopLoss = parseFloat(document.getElementById('stopLoss').value);
            const takeProfit = parseFloat(document.getElementById('takeProfit').value);
            const durationValue = parseInt(document.getElementById('durationValue').value);
            const minLowerWickBuy = parseFloat(document.getElementById('minLowerWickBuy').value);
            const minUpperWickSell = parseFloat(document.getElementById('minUpperWickSell').value);

            if (stakeAmount < 0.35) {
                logActivity('Stake amount must be at least 0.35', 'error');
                document.getElementById('stakeAmount').value = 0.35;
                return false;
            }

            if (stopLoss < 0) {
                logActivity('Stop loss cannot be negative', 'error');
                document.getElementById('stopLoss').value = 0;
                return false;
            }

            if (takeProfit < 0) {
                logActivity('Take profit cannot be negative', 'error');
                document.getElementById('takeProfit').value = 0;
                return false;
            }

            if (durationValue < 1) {
                logActivity('Duration value must be at least 1', 'error');
                document.getElementById('durationValue').value = 1;
                return false;
            }

            if (minLowerWickBuy < 0 || minLowerWickBuy > 100) {
                logActivity('Min lower wick percentage must be between 0 and 100', 'error');
                document.getElementById('minLowerWickBuy').value = 50;
                return false;
            }

            if (minUpperWickSell < 0 || minUpperWickSell > 100) {
                logActivity('Min upper wick percentage must be between 0 and 100', 'error');
                document.getElementById('minUpperWickSell').value = 50;
                return false;
            }

            return true;
        }

        // Add input validation listeners
        document.getElementById('stakeAmount').addEventListener('blur', validateInputs);
        document.getElementById('stopLoss').addEventListener('blur', validateInputs);
        document.getElementById('takeProfit').addEventListener('blur', validateInputs);
        document.getElementById('durationValue').addEventListener('blur', validateInputs);
        document.getElementById('minLowerWickBuy').addEventListener('blur', validateInputs);
        document.getElementById('minUpperWickSell').addEventListener('blur', validateInputs);

        // Monitor WebSocket health
        function checkWebSocketHealth() {
            if (isLoggedIn && ws && ws.readyState === WebSocket.OPEN) {
                const timeSinceLastMessage = Date.now() - lastHeartbeat;
                
                if (timeSinceLastMessage > 30000) {
                    ws.send(JSON.stringify({ ping: 1 }));
                    logActivity('Sending heartbeat ping...', 'info');
                }

                if (timeSinceLastMessage > 60000) {
                    logActivity('No response from server. Reconnecting...', 'error');
                    const token = sessionStorage.getItem('derivToken');
                    if (token) {
                        ws.close();
                        connectWebSocket(token).catch(err => {
                            logActivity('Reconnection failed: ' + err.message, 'error');
                        });
                    }
                }
            }
        }

        setInterval(checkWebSocketHealth, 10000);

        // Error boundaries
        window.addEventListener('error', (e) => {
            logActivity(`Unexpected error: ${e.message}`, 'error');
            console.error('Error details:', e);
        });

        window.addEventListener('unhandledrejection', (e) => {
            logActivity(`Unhandled promise rejection: ${e.reason}`, 'error');
            console.error('Promise rejection details:', e);
        });

        // Export trade history function
        window.exportTradeHistory = function() {
            if (tradeHistory.length === 0) {
                logActivity('No trade history to export', 'error');
                return;
            }

            const csv = [
                ['S/N', 'Time', 'Market', 'Type', 'Stake', 'Result'],
                ...tradeHistory.map((trade, index) => [
                    index + 1,
                    trade.time,
                    trade.market,
                    trade.type,
                    trade.stake,
                    trade.result
                ])
            ].map(row => row.join(',')).join('\n');

            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `ben-sniper-trades-${new Date().toISOString().split('T')[0]}.csv`;
            a.click();
            URL.revokeObjectURL(url);

            logActivity('Trade history exported successfully', 'success');
        };

        // Reset all settings function
        window.resetAllSettings = function() {
            if (confirm('Are you sure you want to reset all settings to default? This will clear all saved data including trade history.')) {
                sessionStorage.clear();
                location.reload();
            }
        };

        // Tooltips
        const tooltips = {
            'stakeAmount': 'Amount to stake per trade (minimum 0.35)',
            'stopLoss': 'Stop trading when total loss reaches this amount',
            'takeProfit': 'Stop trading when total profit reaches this amount',
            'durationType': 'Unit of time for trade duration',
            'durationValue': 'Number of units for trade duration',
            'minLowerWickBuy': 'Minimum lower wick percentage required for Buy signal (0-100%)',
            'minUpperWickSell': 'Minimum upper wick percentage required for Sell signal (0-100%)',
            'trendFilter': 'Only trade in the direction of 50 EMA trend',
            'zeroClosingFilter': 'Only trade on perfect candle closes (no opposite wicks)',
            'ignoreWickPercent': 'Ignore the opposite wick percentage requirement (upper for buy, lower for sell)',
            'ignoreHeight': 'Allow confirmation candle to be shorter (min 50% of first candle body)',
            'ignoreMatchDiff': 'Ignore the low/high match difference requirement',
            'requireEngulfing': 'Require second candle to close beyond first candle body (strict breakout)'
        };

        Object.entries(tooltips).forEach(([id, text]) => {
            const element = document.getElementById(id);
            if (element) {
                element.title = text;
            }
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                e.preventDefault();
                saveSettings();
                logActivity('Settings saved manually', 'success');
            }

            if ((e.ctrlKey || e.metaKey) && e.key === ' ') {
                e.preventDefault();
                if (isLoggedIn && document.getElementById('autoTradeBtn').disabled === false) {
                    if (isAutoTrading) {
                        stopAutoTrading();
                    } else {
                        startAutoTrading();
                    }
                }
            }
        });

        // Visual connection status
        function updateConnectionStatus() {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                document.body.style.borderTop = '3px solid #ff4757';
            } else {
                document.body.style.borderTop = '3px solid #2ecc71';
            }
        }

        setInterval(updateConnectionStatus, 1000);

        // Network status monitoring
        window.addEventListener('online', () => {
            logActivity('Network connection restored', 'success');
            updateConnectionBadge(true);
            if (isLoggedIn && (!ws || ws.readyState !== WebSocket.OPEN)) {
                const token = sessionStorage.getItem('derivToken');
                if (token) {
                    connectWebSocket(token).catch(err => {
                        logActivity('Reconnection failed: ' + err.message, 'error');
                    });
                }
            }
        });

        window.addEventListener('offline', () => {
            logActivity('Network connection lost!', 'error');
            updateConnectionBadge(false);
        });

        // Responsive font sizing
        function adjustFontSizes() {
            const width = window.innerWidth;
            const root = document.documentElement;
            
            if (width < 480) {
                root.style.fontSize = '14px';
            } else if (width < 768) {
                root.style.fontSize = '15px';
            } else {
                root.style.fontSize = '16px';
            }
        }

        window.addEventListener('resize', adjustFontSizes);
        adjustFontSizes();

        // Initialize app
        loadSettings();
        renderMarkets();
        logActivity('System initialized. Please login to continue.', 'success');

        // Auto-reconnect on page refresh
        window.addEventListener('load', () => {
            const savedToken = sessionStorage.getItem('derivToken');
            if (savedToken && !isLoggedIn) {
                document.getElementById('apiToken').value = savedToken;
                logActivity('Auto-reconnect: Token found in storage', 'info');
            }
        });

        // Prevent data loss on page unload
        window.addEventListener('beforeunload', () => {
            saveSettings();
        });

        // Log system information
        logActivity(`Browser: ${navigator.userAgent}`, 'info');
        logActivity(`Screen resolution: ${window.screen.width}x${window.screen.height}`, 'info');
        logActivity(`Available markets: ${Object.keys(markets).length}`, 'info');

        // Startup complete
        setTimeout(() => {
            logActivity('Ben Sniper Bot initialized successfully!', 'success');
            logActivity('Tip: Press Ctrl+Space to toggle auto trading', 'info');
            logActivity('Tip: Use console command exportTradeHistory() to export trades', 'info');
        }, 1000);
    </script>
</body>
</html>