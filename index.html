<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ben Sniper - Deriv Trading Bot</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 100%);
            color: #e0e0e0;
            min-height: 100vh;
            padding: 10px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            background: linear-gradient(135deg, #1e2749 0%, #2d3561 100%);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            position: relative;
        }

        .connection-badge {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 20px;
            border: 2px solid;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            transition: all 0.3s ease;
        }

        .connection-badge.connected {
            border-color: #2ecc71;
            color: #2ecc71;
        }

        .connection-badge.disconnected {
            border-color: #ff4757;
            color: #ff4757;
        }

        .connection-badge.reconnecting {
            border-color: #f39c12;
            color: #f39c12;
        }

        .connection-badge-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            animation: badge-pulse 2s infinite;
        }

        .connection-badge.connected .connection-badge-dot {
            background-color: #2ecc71;
        }

        .connection-badge.disconnected .connection-badge-dot {
            background-color: #ff4757;
        }

        .connection-badge.reconnecting .connection-badge-dot {
            background-color: #f39c12;
        }

        @keyframes badge-pulse {
            0%, 100% {
                opacity: 1;
                transform: scale(1);
            }
            50% {
                opacity: 0.6;
                transform: scale(1.2);
            }
        }

        .header h1 {
            color: #00d4ff;
            font-size: 28px;
            margin-bottom: 15px;
            text-align: center;
            padding-right: 150px;
        }

        .login-section {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 15px;
        }

        .login-input-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .login-input {
            flex: 1;
            min-width: 200px;
            padding: 12px;
            background: #2a3250;
            border: 2px solid #3d4663;
            border-radius: 5px;
            color: #e0e0e0;
            font-size: 14px;
        }

        .login-input:focus {
            outline: none;
            border-color: #00d4ff;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }

        .btn-primary {
            background: linear-gradient(135deg, #00d4ff 0%, #0099cc 100%);
            color: #0a0e27;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 212, 255, 0.4);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ff4757 0%, #cc3544 100%);
            color: white;
        }

        .btn-danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(255, 71, 87, 0.4);
        }

        .btn-success {
            background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
            color: white;
        }

        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(46, 204, 113, 0.4);
        }

        .btn-warning {
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
            color: white;
        }

        .btn-warning:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(243, 156, 18, 0.4);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .account-info {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 10px;
            padding: 15px;
            background: rgba(0, 212, 255, 0.1);
            border-radius: 5px;
            margin-top: 10px;
        }

        .info-item {
            text-align: center;
        }

        .info-label {
            font-size: 11px;
            color: #8899aa;
            text-transform: uppercase;
        }

        .info-value {
            font-size: 16px;
            font-weight: 700;
            color: #00d4ff;
            margin-top: 5px;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .panel {
            background: #1e2749;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .panel-title {
            color: #00d4ff;
            font-size: 18px;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #3d4663;
        }

        .markets-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }

        .market-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: #2a3250;
            border-radius: 5px;
            border: 1px solid #3d4663;
            position: relative;
        }

        .market-name {
            font-size: 13px;
            color: #e0e0e0;
            flex: 1;
        }

        .market-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .subscription-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: #3d4663;
            transition: all 0.3s ease;
        }

        .subscription-indicator.subscribing {
            background-color: #f1c40f;
            box-shadow: 0 0 10px rgba(241, 196, 15, 0.6);
            animation: pulse-yellow 1s infinite;
        }

        .subscription-indicator.subscribed {
            background-color: #2ecc71;
            box-shadow: 0 0 10px rgba(46, 204, 113, 0.6);
            animation: glow 2s infinite;
        }

        @keyframes pulse-yellow {
            0%, 100% {
                opacity: 1;
                transform: scale(1);
            }
            50% {
                opacity: 0.6;
                transform: scale(1.2);
            }
        }

        @keyframes glow {
            0%, 100% {
                box-shadow: 0 0 5px rgba(46, 204, 113, 0.6);
            }
            50% {
                box-shadow: 0 0 15px rgba(46, 204, 113, 0.9);
            }
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #3d4663;
            transition: 0.3s;
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #00d4ff;
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }

        .filter-section {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 15px;
        }

        .filter-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            background: #2a3250;
            border-radius: 5px;
            border: 1px solid #3d4663;
        }

        .filter-label {
            font-size: 14px;
            color: #e0e0e0;
        }

        .settings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .input-label {
            font-size: 12px;
            color: #8899aa;
            text-transform: uppercase;
        }

        .input-field {
            padding: 10px;
            background: #2a3250;
            border: 2px solid #3d4663;
            border-radius: 5px;
            color: #e0e0e0;
            font-size: 14px;
        }

        .input-field:focus {
            outline: none;
            border-color: #00d4ff;
        }

        .select-field {
            padding: 10px;
            background: #2a3250;
            border: 2px solid #3d4663;
            border-radius: 5px;
            color: #e0e0e0;
            font-size: 14px;
            cursor: pointer;
        }

        .select-field:focus {
            outline: none;
            border-color: #00d4ff;
        }

        .control-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .control-buttons .btn {
            flex: 1;
            min-width: 120px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .stat-card {
            background: #2a3250;
            padding: 15px;
            border-radius: 5px;
            text-align: center;
            border: 1px solid #3d4663;
        }

        .stat-label {
            font-size: 11px;
            color: #8899aa;
            text-transform: uppercase;
            margin-bottom: 8px;
        }

        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: #00d4ff;
        }

        .stat-value.profit {
            color: #2ecc71;
        }

        .stat-value.loss {
            color: #ff4757;
        }

        .signal-monitor {
            background: #1e2749;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            margin-bottom: 20px;
        }

        .monitor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 15px;
            background: #2a3250;
            border-radius: 20px;
        }

        .pulse-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #ff4757;
            animation: pulse 2s infinite;
        }

        .pulse-dot.active {
            background-color: #2ecc71;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
                transform: scale(1);
            }
            50% {
                opacity: 0.5;
                transform: scale(1.1);
            }
        }

        .status-text {
            font-size: 13px;
            color: #ff4757;
            font-weight: 600;
        }

        .status-text.active {
            color: #2ecc71;
        }

        .signals-container {
            max-height: 300px;
            overflow-y: auto;
            background: #0a0e27;
            padding: 15px;
            border-radius: 5px;
        }

        .signals-container::-webkit-scrollbar {
            width: 8px;
        }

        .signals-container::-webkit-scrollbar-track {
            background: #1e2749;
            border-radius: 10px;
        }

        .signals-container::-webkit-scrollbar-thumb {
            background: #00d4ff;
            border-radius: 10px;
        }

        .signal-item {
            padding: 12px;
            margin-bottom: 10px;
            border-radius: 5px;
            border-left: 4px solid #3d4663;
            background: #1e2749;
            transition: all 0.3s ease;
        }

        .signal-item.win {
            border-left-color: #2ecc71;
            background: rgba(46, 204, 113, 0.1);
        }

        .signal-item.loss {
            border-left-color: #ff4757;
            background: rgba(255, 71, 87, 0.1);
        }

        .signal-text {
            font-size: 13px;
            color: #e0e0e0;
        }

        .trade-history {
            background: #1e2749;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            margin-bottom: 20px;
        }

        .history-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .history-table {
            width: 100%;
            border-collapse: collapse;
            background: #0a0e27;
            border-radius: 5px;
            overflow: hidden;
        }

        .history-table thead {
            background: #2a3250;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .history-table th {
            padding: 12px;
            text-align: left;
            font-size: 12px;
            color: #8899aa;
            text-transform: uppercase;
            font-weight: 600;
        }

        .history-table td {
            padding: 12px;
            border-top: 1px solid #1e2749;
            font-size: 13px;
            color: #e0e0e0;
        }

        .history-table-container {
            max-height: 500px;
            overflow-y: auto;
            overflow-x: auto;
            border-radius: 5px;
        }

        .history-table-container::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        .history-table-container::-webkit-scrollbar-track {
            background: #1e2749;
            border-radius: 10px;
        }

        .history-table-container::-webkit-scrollbar-thumb {
            background: #00d4ff;
            border-radius: 10px;
        }

        .history-table-container::-webkit-scrollbar-thumb:hover {
            background: #0099cc;
        }

        .result-win {
            color: #2ecc71;
            font-weight: 600;
        }

        .result-loss {
            color: #ff4757;
            font-weight: 600;
        }

        .activities-log {
            background: #1e2749;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .log-container {
            max-height: 300px;
            overflow-y: auto;
            background: #0a0e27;
            padding: 15px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
        }

        .log-container::-webkit-scrollbar {
            width: 8px;
        }

        .log-container::-webkit-scrollbar-track {
            background: #1e2749;
            border-radius: 10px;
        }

        .log-container::-webkit-scrollbar-thumb {
            background: #00d4ff;
            border-radius: 10px;
        }

        .log-entry {
            font-size: 12px;
            color: #8899aa;
            margin-bottom: 8px;
            line-height: 1.5;
        }

        .log-entry .timestamp {
            color: #00d4ff;
            margin-right: 10px;
        }

        .log-entry.error {
            color: #ff4757;
        }

        .log-entry.success {
            color: #2ecc71;
        }

        .log-entry.warning {
            color: #f39c12;
        }

        .reverse-mode-badge {
            display: inline-block;
            padding: 4px 10px;
            background: rgba(243, 156, 18, 0.2);
            border: 1px solid #f39c12;
            border-radius: 4px;
            color: #f39c12;
            font-size: 11px;
            font-weight: 600;
            margin-left: 10px;
        }

        .conflict-alert {
            background: rgba(243, 156, 18, 0.15);
            border: 2px solid #f39c12;
            border-radius: 5px;
            padding: 15px;
            margin-top: 15px;
            display: none;
        }

        .conflict-alert.active {
            display: block;
            animation: conflict-pulse 2s infinite;
        }

        @keyframes conflict-pulse {
            0%, 100% {
                background: rgba(243, 156, 18, 0.15);
            }
            50% {
                background: rgba(243, 156, 18, 0.25);
            }
        }

        .conflict-title {
            color: #f39c12;
            font-weight: 700;
            font-size: 14px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .conflict-list {
            color: #e0e0e0;
            font-size: 12px;
            line-height: 1.6;
            margin-left: 24px;
        }

        @media (max-width: 768px) {
            .main-grid {
                grid-template-columns: 1fr;
            }

            .header h1 {
                font-size: 22px;
                padding-right: 0;
                margin-top: 40px;
            }

            .connection-badge {
                top: 10px;
                right: 10px;
                font-size: 10px;
                padding: 6px 12px;
            }

            .markets-grid {
                grid-template-columns: 1fr;
            }

            .settings-grid {
                grid-template-columns: 1fr;
            }

            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .control-buttons {
                flex-direction: column;
            }

            .control-buttons .btn {
                width: 100%;
            }

            .history-table {
                font-size: 11px;
            }

            .history-table th,
            .history-table td {
                padding: 8px 5px;
            }
        }

        .timer-display {
            text-align: center;
            padding: 10px;
            background: rgba(0, 212, 255, 0.1);
            border-radius: 5px;
            margin-top: 10px;
        }

        .timer-label {
            font-size: 11px;
            color: #8899aa;
            text-transform: uppercase;
        }

        .timer-value {
            font-size: 20px;
            font-weight: 700;
            color: #00d4ff;
            margin-top: 5px;
            font-family: 'Courier New', monospace;
        }

        .hidden {
            display: none;
        }

        .candle-counter {
            font-size: 13px;
            color: #f1c40f;
            font-weight: 600;
            margin-top: 10px;
            text-align: center;
            padding: 8px;
            background: rgba(241, 196, 15, 0.1);
            border-radius: 5px;
        }

        .trade-count-display {
            text-align: center;
            font-size: 12px;
            color: #8899aa;
            margin-top: 10px;
            padding: 8px;
            background: rgba(0, 212, 255, 0.05);
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <!-- Connection Badge -->
            <div class="connection-badge disconnected" id="connectionBadge">
                <div class="connection-badge-dot"></div>
                <span id="connectionStatus">Disconnected</span>
            </div>

            <h1>‚ö° BEN SNIPER - Deriv Trading Bot</h1>
            
            <div class="login-section" id="loginSection">
                <div class="login-input-group">
                    <input type="password" class="login-input" id="apiToken" placeholder="Enter Deriv API Token">
                    <button class="btn btn-primary" id="loginBtn">Login</button>
                </div>
            </div>

            <div class="account-info hidden" id="accountInfo">
                <div class="info-item">
                    <div class="info-label">Account Type</div>
                    <div class="info-value" id="accountType">-</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Currency</div>
                    <div class="info-value" id="accountCurrency">-</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Balance</div>
                    <div class="info-value" id="accountBalance">-</div>
                </div>
                <div class="info-item">
                    <button class="btn btn-danger" id="logoutBtn">Logout</button>
                </div>
            </div>

            <div class="timer-display hidden" id="timerDisplay">
                <div class="timer-label">Session Time</div>
                <div class="timer-value" id="timerValue">00:00:00</div>
            </div>
        </div>

        <div class="signal-monitor">
            <div class="monitor-header">
                <h2 class="panel-title">üìä Signal Monitor<span id="reverseModeIndicator" class="reverse-mode-badge hidden">REVERSE MODE</span></h2>
                <div class="status-indicator">
                    <div class="pulse-dot" id="statusDot"></div>
                    <span class="status-text" id="statusText">Bot Inactive</span>
                </div>
            </div>
            <div id="candleCounter" class="candle-counter hidden">Building candles: 0 / 0 required</div>
            <div class="signals-container" id="signalsContainer">
                <div class="signal-item">
                    <div class="signal-text">Waiting for bot activation...</div>
                </div>
            </div>
        </div>

        <div class="main-grid">
            <div class="panel">
                <h2 class="panel-title">üéØ Market Selection</h2>
                <div class="markets-grid" id="marketsGrid"></div>
            </div>

            <div class="panel">
                <h2 class="panel-title">üîß Filters</h2>
                <div class="filter-section">
                    <div class="filter-item">
                        <span class="filter-label">RSI Filter (Oversold/Overbought)</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="rsiFilter">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="filter-item">
                        <span class="filter-label">Trend Structure (HH+HL / LL+LH)</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="trendStructureFilter">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="filter-item">
                        <span class="filter-label">Zero Closing Filter (Perfect 0)</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="zeroClosingFilter">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="filter-item">
                        <span class="filter-label">Ignore Height</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="ignoreHeightFilter">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="filter-item">
                        <span class="filter-label">Length Filter</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="lengthFilter">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="filter-item">
                        <span class="filter-label">Reverse Candle</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="reverseCandleFilter">
                            <span class="slider"></span>
                        </label>
                    </div>
                </div>

                <!-- Conflict Alert Box -->
                <div class="conflict-alert" id="conflictAlert">
                    <div class="conflict-title">
                        ‚ö†Ô∏è Filter Conflict Detected
                    </div>
                    <div class="conflict-list" id="conflictList"></div>
                </div>

                <h2 class="panel-title" style="margin-top: 20px;">‚öôÔ∏è Trade Settings</h2>
                <div class="settings-grid">
                    <div class="input-group">
                        <label class="input-label">Stake Amount</label>
                        <input type="number" class="input-field" id="stakeAmount" value="1" min="0.35" step="0.01">
                    </div>
                    <div class="input-group">
                        <label class="input-label">Stop Loss</label>
                        <input type="number" class="input-field" id="stopLoss" value="10" min="0" step="1">
                    </div>
                    <div class="input-group">
                        <label class="input-label">Take Profit</label>
                        <input type="number" class="input-field" id="takeProfit" value="20" min="0" step="1">
                    </div>
                    <div class="input-group">
                        <label class="input-label">RSI Period</label>
                        <input type="number" class="input-field" id="rsiPeriod" value="14" min="5" max="50" step="1">
                    </div>
                    <div class="input-group">
                        <label class="input-label">RSI Oversold</label>
                        <input type="number" class="input-field" id="rsiOversold" value="30" min="10" max="50" step="1">
                    </div>
                    <div class="input-group">
                        <label class="input-label">RSI Overbought</label>
                        <input type="number" class="input-field" id="rsiOverbought" value="70" min="50" max="90" step="1">
                    </div>
                    <div class="input-group">
                        <label class="input-label">Trend Lookback</label>
                        <input type="number" class="input-field" id="trendLookback" value="5" min="3" max="20" step="1">
                    </div>
                    <div class="input-group">
                        <label class="input-label">Duration Type</label>
                        <select class="select-field" id="durationType">
                            <option value="t">Ticks</option>
                            <option value="s">Seconds</option>
                            <option value="m">Minutes</option>
                        </select>
                    </div>
                    <div class="input-group">
                        <label class="input-label">Duration Value</label>
                        <input type="number" class="input-field" id="durationValue" value="5" min="1" step="1">
                    </div>
                    <div class="input-group">
                        <label class="input-label">Min Lower Wick % (Buy)</label>
                        <input type="number" class="input-field" id="minLowerWickBuy" value="50" min="0" max="100" step="1">
                    </div>
                    <div class="input-group">
                        <label class="input-label">Min Upper Wick % (Sell)</label>
                        <input type="number" class="input-field" id="minUpperWickSell" value="50" min="0" max="100" step="1">
                    </div>
                    <div class="input-group">
                        <label class="input-label">Min Upper Wick % (Buy)</label>
                        <input type="number" class="input-field" id="minUpperWickBuy" value="20" min="0" max="100" step="1">
                    </div>
                    <div class="input-group">
                        <label class="input-label">Min Lower Wick % (Sell)</label>
                        <input type="number" class="input-field" id="minLowerWickSell" value="20" min="0" max="100" step="1">
                    </div>
                    <div class="input-group">
                        <label class="input-label">Matching Diff % (Buy)</label>
                        <input type="number" class="input-field" id="matchingDiffBuy" value="0.3" min="0" max="5" step="0.1">
                    </div>
                    <div class="input-group">
                        <label class="input-label">Matching Diff % (Sell)</label>
                        <input type="number" class="input-field" id="matchingDiffSell" value="0.3" min="0" max="5" step="0.1">
                    </div>
                </div>

                <div class="control-buttons">
                    <button class="btn btn-success" id="autoTradeBtn" disabled>Start Auto Trade</button>
                    <button class="btn btn-warning" id="reverseModeBtn" disabled>Reverse Mode: OFF</button>
                </div>
            </div>
        </div>

        <div class="panel">
            <h2 class="panel-title">üìà Trading Statistics</h2>
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-label">Total Trades</div>
                    <div class="stat-value" id="totalTrades">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Wins</div>
                    <div class="stat-value profit" id="totalWins">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Losses</div>
                    <div class="stat-value loss" id="totalLosses">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">P/L</div>
                    <div class="stat-value" id="profitLoss">0.00</div>
                </div>
            </div>
        </div>

        <div class="trade-history">
            <div class="history-header">
                <h2 class="panel-title">üìã Trade History</h2>
                <button class="btn btn-danger" id="clearHistoryBtn">Clear History</button>
            </div>
            <div class="trade-count-display" id="tradeCountDisplay">Showing 0 of 0 trades</div>
            <div class="history-table-container">
                <table class="history-table">
                    <thead>
                        <tr>
                            <th>S/N</th>
                            <th>Time</th>
                            <th>Market</th>
                            <th>Type</th>
                            <th>Stake</th>
                            <th>Result</th>
                        </tr>
                    </thead>
                    <tbody id="historyTableBody">
                        <tr>
                            <td colspan="6" style="text-align: center; color: #8899aa;">No trades yet</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="activities-log">
            <h2 class="panel-title">üìù Activity Log</h2>
            <div class="log-container" id="logContainer">
                <div class="log-entry">
                    <span class="timestamp">[--:--:--]</span> System initialized. Waiting for login...
                </div>
            </div>
        </div>
    </div>

    <script>
        // Market definitions
        const markets = {
            '1HZ10V': 'Volatility 10 (1s)',
            '1HZ25V': 'Volatility 25 (1s)',
            '1HZ50V': 'Volatility 50 (1s)',
            '1HZ75V': 'Volatility 75 (1s)',
            '1HZ100V': 'Volatility 100 (1s)',
            'R_10': 'Volatility 10',
            'R_25': 'Volatility 25',
            'R_50': 'Volatility 50',
            'R_75': 'Volatility 75',
            'R_100': 'Volatility 100',
            'stpRNG': 'Step Index 100',
            'stpRNG2': 'Step Index 200',
            'stpRNG3': 'Step Index 300',
            'stpRNG4': 'Step Index 400',
            'stpRNG5': 'Step Index 500'
        };

        // Global state
        let ws = null;
        let isLoggedIn = false;
        let isAutoTrading = false;
        let isReverseMode = false;
        let activation_time = 0;
        let activeMarkets = {};
        let marketSubscriptions = {};
        let pendingSubscriptions = {};
        let candleData = {};
        let currentOHLC = {};
        let currentMinute = {};
        let tradeHistory = [];
        let sessionTimer = null;
        let sessionStartTime = null;
        let accountInfo = {};
        let tradeStats = {
            total: 0,
            wins: 0,
            losses: 0,
            profitLoss: 0
        };
        let pendingTrades = new Map();
        let isFirstSignal = true;
        let lastHeartbeat = Date.now();
        let tradedCandles = {};
        let requestIdCounter = 0;
        let pendingProposals = new Map();
        
        // Time synchronization variables
        let serverTimeOffset = 0;
        let isTimeSynced = false;
        let candleWatchdogTimer = null;

        // RSI cache for optimization
        let rsiCache = {};

        // Auto-reconnect variables
        let reconnectAttempts = 0;
        let maxReconnectAttempts = 10;
        let reconnectTimeout = null;
        let wasAutoTradingBeforeDisconnect = false;

        // Initialize markets
        Object.keys(markets).forEach(symbol => {
            activeMarkets[symbol] = true;
            candleData[symbol] = [];
            currentOHLC[symbol] = undefined;
            currentMinute[symbol] = undefined;
            tradedCandles[symbol] = new Set();
            rsiCache[symbol] = {};
        });

        // Update connection badge
        function updateConnectionBadge(status) {
            const badge = document.getElementById('connectionBadge');
            const statusText = document.getElementById('connectionStatus');
            
            badge.className = 'connection-badge ' + status;
            
            if (status === 'connected') {
                statusText.textContent = 'Connected';
            } else if (status === 'disconnected') {
                statusText.textContent = 'Disconnected';
            } else if (status === 'reconnecting') {
                statusText.textContent = 'Reconnecting...';
            }
        }

        // Update subscription indicator for a specific market
        function updateSubscriptionIndicator(symbol, state) {
            const indicator = document.querySelector(`[data-indicator="${symbol}"]`);
            if (indicator) {
                indicator.className = 'subscription-indicator';
                if (state === 'subscribing') {
                    indicator.classList.add('subscribing');
                } else if (state === 'subscribed') {
                    indicator.classList.add('subscribed');
                }
            }
        }

        // Update reverse mode indicator
        function updateReverseModeIndicator() {
            const indicator = document.getElementById('reverseModeIndicator');
            if (isReverseMode) {
                indicator.classList.remove('hidden');
            } else {
                indicator.classList.add('hidden');
            }
        }

        // Check for filter conflicts
        function checkFilterConflicts() {
            const ignoreHeight = document.getElementById('ignoreHeightFilter').checked;
            const lengthFilter = document.getElementById('lengthFilter').checked;
            const conflictAlert = document.getElementById('conflictAlert');
            const conflictList = document.getElementById('conflictList');
            
            const conflicts = [];
            
            if (ignoreHeight && lengthFilter) {
                conflicts.push('‚Ä¢ "Ignore Height" and "Length Filter" are both enabled. These filters contradict each other:<br>&nbsp;&nbsp;- Ignore Height: Allows confirmation candle to be any height<br>&nbsp;&nbsp;- Length Filter: Restricts confirmation candle height to be ‚â§ first candle<br>&nbsp;&nbsp;‚Üí Length Filter will be ignored when Ignore Height is active');
            }
            
            if (conflicts.length > 0) {
                conflictList.innerHTML = conflicts.join('<br><br>');
                conflictAlert.classList.add('active');
                logActivity('Filter conflict detected! Check the warning box in Filters section', 'warning');
            } else {
                conflictAlert.classList.remove('active');
            }
        }

        // Update candle counter
        function updateCandleCounter() {
            if (!isAutoTrading) {
                document.getElementById('candleCounter').classList.add('hidden');
                return;
            }

            const rsiFilter = document.getElementById('rsiFilter').checked;
            const trendStructureFilter = document.getElementById('trendStructureFilter').checked;
            const rsiPeriod = parseInt(document.getElementById('rsiPeriod').value);
            const trendLookback = parseInt(document.getElementById('trendLookback').value);
            
            let requiredCandles = 3;
            if (rsiFilter) {
                requiredCandles = Math.max(requiredCandles, rsiPeriod + 2);
            }
            if (trendStructureFilter) {
                requiredCandles = Math.max(requiredCandles, trendLookback + 2);
            }
            
            let minCandles = Infinity;
            let activeCount = 0;
            
            Object.keys(activeMarkets).forEach(symbol => {
                if (activeMarkets[symbol] && marketSubscriptions[symbol]) {
                    activeCount++;
                    const count = candleData[symbol].length;
                    if (count < minCandles) {
                        minCandles = count;
                    }
                }
            });

            if (activeCount === 0) {
                document.getElementById('candleCounter').classList.add('hidden');
                return;
            }

            if (minCandles === Infinity) minCandles = 0;

            const counterElement = document.getElementById('candleCounter');
            
            if (minCandles >= requiredCandles) {
                counterElement.textContent = `‚úì Ready to analyze - All markets have ${requiredCandles}+ candles`;
                counterElement.style.color = '#2ecc71';
                counterElement.style.background = 'rgba(46, 204, 113, 0.1)';
            } else {
                counterElement.textContent = `Building candles: ${minCandles} / ${requiredCandles} required (${requiredCandles - minCandles} more needed)`;
                counterElement.style.color = '#f1c40f';
                counterElement.style.background = 'rgba(241, 196, 15, 0.1)';
            }
            
            counterElement.classList.remove('hidden');
        }

        // Update trade count display
        function updateTradeCountDisplay() {
            const totalTrades = tradeHistory.length;
            const displayElement = document.getElementById('tradeCountDisplay');
            
            if (totalTrades === 0) {
                displayElement.textContent = 'No trades yet';
            } else if (totalTrades <= 100) {
                displayElement.textContent = `Showing all ${totalTrades} trade${totalTrades === 1 ? '' : 's'}`;
            } else {
                displayElement.textContent = `Showing latest 100 of ${totalTrades} total trades`;
            }
        }

        // Load saved settings
        function loadSettings() {
            const savedToken = sessionStorage.getItem('derivToken');
            const savedMarkets = sessionStorage.getItem('activeMarkets');
            const savedRsiFilter = sessionStorage.getItem('rsiFilter');
            const savedTrendStructureFilter = sessionStorage.getItem('trendStructureFilter');
            const savedZeroFilter = sessionStorage.getItem('zeroClosingFilter');
            const savedIgnoreHeightFilter = sessionStorage.getItem('ignoreHeightFilter');
            const savedLengthFilter = sessionStorage.getItem('lengthFilter');
            const savedReverseCandleFilter = sessionStorage.getItem('reverseCandleFilter');
            const savedReverseMode = sessionStorage.getItem('reverseMode');
            const savedStake = sessionStorage.getItem('stakeAmount');
            const savedStopLoss = sessionStorage.getItem('stopLoss');
            const savedTakeProfit = sessionStorage.getItem('takeProfit');
            const savedRsiPeriod = sessionStorage.getItem('rsiPeriod');
            const savedRsiOversold = sessionStorage.getItem('rsiOversold');
            const savedRsiOverbought = sessionStorage.getItem('rsiOverbought');
            const savedTrendLookback = sessionStorage.getItem('trendLookback');
            const savedDurationType = sessionStorage.getItem('durationType');
            const savedDurationValue = sessionStorage.getItem('durationValue');
            const savedMinLowerWickBuy = sessionStorage.getItem('minLowerWickBuy');
            const savedMinUpperWickSell = sessionStorage.getItem('minUpperWickSell');
            const savedMinUpperWickBuy = sessionStorage.getItem('minUpperWickBuy');
            const savedMinLowerWickSell = sessionStorage.getItem('minLowerWickSell');
            const savedMatchingDiffBuy = sessionStorage.getItem('matchingDiffBuy');
            const savedMatchingDiffSell = sessionStorage.getItem('matchingDiffSell');
            const savedTradeHistory = sessionStorage.getItem('tradeHistory');
            const savedStats = sessionStorage.getItem('tradeStats');

            if (savedToken) {
                document.getElementById('apiToken').value = savedToken;
            }

            if (savedMarkets) {
                activeMarkets = JSON.parse(savedMarkets);
            }

            if (savedRsiFilter) {
                document.getElementById('rsiFilter').checked = savedRsiFilter === 'true';
            }

            if (savedTrendStructureFilter) {
                document.getElementById('trendStructureFilter').checked = savedTrendStructureFilter === 'true';
            }

            if (savedZeroFilter) {
                document.getElementById('zeroClosingFilter').checked = savedZeroFilter === 'true';
            }

            if (savedIgnoreHeightFilter) {
                document.getElementById('ignoreHeightFilter').checked = savedIgnoreHeightFilter === 'true';
            }

            if (savedLengthFilter) {
                document.getElementById('lengthFilter').checked = savedLengthFilter === 'true';
            }

            if (savedReverseCandleFilter) {
                document.getElementById('reverseCandleFilter').checked = savedReverseCandleFilter === 'true';
            }

            if (savedReverseMode) {
                isReverseMode = savedReverseMode === 'true';
                updateReverseModeButton();
                updateReverseModeIndicator();
            }

            if (savedStake) document.getElementById('stakeAmount').value = savedStake;
            if (savedStopLoss) document.getElementById('stopLoss').value = savedStopLoss;
            if (savedTakeProfit) document.getElementById('takeProfit').value = savedTakeProfit;
            if (savedRsiPeriod) document.getElementById('rsiPeriod').value = savedRsiPeriod;
            if (savedRsiOversold) document.getElementById('rsiOversold').value = savedRsiOversold;
            if (savedRsiOverbought) document.getElementById('rsiOverbought').value = savedRsiOverbought;
            if (savedTrendLookback) document.getElementById('trendLookback').value = savedTrendLookback;
            if (savedDurationType) document.getElementById('durationType').value = savedDurationType;
            if (savedDurationValue) document.getElementById('durationValue').value = savedDurationValue;
            if (savedMinLowerWickBuy) document.getElementById('minLowerWickBuy').value = savedMinLowerWickBuy;
            if (savedMinUpperWickSell) document.getElementById('minUpperWickSell').value = savedMinUpperWickSell;
            if (savedMinUpperWickBuy) document.getElementById('minUpperWickBuy').value = savedMinUpperWickBuy;
            if (savedMinLowerWickSell) document.getElementById('minLowerWickSell').value = savedMinLowerWickSell;
            if (savedMatchingDiffBuy) document.getElementById('matchingDiffBuy').value = savedMatchingDiffBuy;
            if (savedMatchingDiffSell) document.getElementById('matchingDiffSell').value = savedMatchingDiffSell;

            if (savedTradeHistory) {
                tradeHistory = JSON.parse(savedTradeHistory);
                updateTradeHistoryTable();
            }

            if (savedStats) {
                tradeStats = JSON.parse(savedStats);
                updateStats();
            }

            checkFilterConflicts();
        }

        // Save settings
        function saveSettings() {
            sessionStorage.setItem('derivToken', document.getElementById('apiToken').value);
            sessionStorage.setItem('activeMarkets', JSON.stringify(activeMarkets));
            sessionStorage.setItem('rsiFilter', document.getElementById('rsiFilter').checked);
            sessionStorage.setItem('trendStructureFilter', document.getElementById('trendStructureFilter').checked);
            sessionStorage.setItem('zeroClosingFilter', document.getElementById('zeroClosingFilter').checked);
            sessionStorage.setItem('ignoreHeightFilter', document.getElementById('ignoreHeightFilter').checked);
            sessionStorage.setItem('lengthFilter', document.getElementById('lengthFilter').checked);
            sessionStorage.setItem('reverseCandleFilter', document.getElementById('reverseCandleFilter').checked);
            sessionStorage.setItem('reverseMode', isReverseMode);
            sessionStorage.setItem('stakeAmount', document.getElementById('stakeAmount').value);
            sessionStorage.setItem('stopLoss', document.getElementById('stopLoss').value);
            sessionStorage.setItem('takeProfit', document.getElementById('takeProfit').value);
            sessionStorage.setItem('rsiPeriod', document.getElementById('rsiPeriod').value);
            sessionStorage.setItem('rsiOversold', document.getElementById('rsiOversold').value);
            sessionStorage.setItem('rsiOverbought', document.getElementById('rsiOverbought').value);
            sessionStorage.setItem('trendLookback', document.getElementById('trendLookback').value);
            sessionStorage.setItem('durationType', document.getElementById('durationType').value);
            sessionStorage.setItem('durationValue', document.getElementById('durationValue').value);
            sessionStorage.setItem('minLowerWickBuy', document.getElementById('minLowerWickBuy').value);
            sessionStorage.setItem('minUpperWickSell', document.getElementById('minUpperWickSell').value);
            sessionStorage.setItem('minUpperWickBuy', document.getElementById('minUpperWickBuy').value);
            sessionStorage.setItem('minLowerWickSell', document.getElementById('minLowerWickSell').value);
            sessionStorage.setItem('matchingDiffBuy', document.getElementById('matchingDiffBuy').value);
            sessionStorage.setItem('matchingDiffSell', document.getElementById('matchingDiffSell').value);
            sessionStorage.setItem('tradeHistory', JSON.stringify(tradeHistory));
            sessionStorage.setItem('tradeStats', JSON.stringify(tradeStats));
            sessionStorage.setItem('wasAutoTrading', isAutoTrading);
        }

        // Render markets with subscription indicators
        function renderMarkets() {
            const grid = document.getElementById('marketsGrid');
            grid.innerHTML = '';

            Object.entries(markets).forEach(([symbol, name]) => {
                const div = document.createElement('div');
                div.className = 'market-item';
                div.innerHTML = `
                    <span class="market-name">${name}</span>
                    <div class="market-controls">
                        <div class="subscription-indicator" data-indicator="${symbol}"></div>
                        <label class="toggle-switch">
                            <input type="checkbox" ${activeMarkets[symbol] ? 'checked' : ''} data-symbol="${symbol}">
                            <span class="slider"></span>
                        </label>
                    </div>
                `;
                grid.appendChild(div);

                const toggle = div.querySelector('input');
                toggle.addEventListener('change', (e) => {
                    activeMarkets[symbol] = e.target.checked;
                    logActivity(`Market ${name} ${e.target.checked ? 'enabled' : 'disabled'}`);
                    saveSettings();
                    
                    if (isLoggedIn && isAutoTrading) {
                        if (e.target.checked) {
                            subscribeToMarket(symbol);
                        } else {
                            unsubscribeFromMarket(symbol);
                        }
                    }
                });
            });
        }

        // Log activity
        function logActivity(message, type = 'info') {
            const container = document.getElementById('logContainer');
            const time = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.innerHTML = `<span class="timestamp">[${time}]</span> ${message}`;
            container.insertBefore(entry, container.firstChild);
            
            while (container.children.length > 100) {
                container.removeChild(container.lastChild);
            }
        }

        // Function to safely close a candle
        function finalizeCandle(symbol, closeTime, closePrice) {
            if (!currentOHLC[symbol]) return;

            const completedCandle = {
                time: currentMinute[symbol],
                open: currentOHLC[symbol].open,
                high: currentOHLC[symbol].high,
                low: currentOHLC[symbol].low,
                close: currentOHLC[symbol].close
            };

            candleData[symbol].push(completedCandle);
            
            // Clear RSI cache for this symbol
            rsiCache[symbol] = {};
            
            if (candleData[symbol].length > 100) {
                candleData[symbol].shift();
            }

            currentMinute[symbol] = closeTime;
            
            currentOHLC[symbol] = {
                open: closePrice,
                high: closePrice,
                low: closePrice,
                close: closePrice
            };

            updateCandleCounter();
            
            const rsiFilter = document.getElementById('rsiFilter').checked;
            const trendStructureFilter = document.getElementById('trendStructureFilter').checked;
            const rsiPeriod = parseInt(document.getElementById('rsiPeriod').value);
            const trendLookback = parseInt(document.getElementById('trendLookback').value);
            
            let requiredCandles = 3;
            if (rsiFilter) {
                requiredCandles = Math.max(requiredCandles, rsiPeriod + 2);
            }
            if (trendStructureFilter) {
                requiredCandles = Math.max(requiredCandles, trendLookback + 2);
            }
            
            if (isAutoTrading && candleData[symbol].length >= requiredCandles) {
                checkForSignals(symbol);
            }
        }

        // Enhanced Connect to Deriv API with auto-reconnect
        function connectWebSocket(token, isReconnect = false) {
            return new Promise((resolve, reject) => {
                if (reconnectTimeout) {
                    clearTimeout(reconnectTimeout);
                    reconnectTimeout = null;
                }

                ws = new WebSocket('wss://ws.derivws.com/websockets/v3?app_id=116948');

                ws.onopen = () => {
                    if (isReconnect) {
                        logActivity('WebSocket reconnected successfully', 'success');
                        reconnectAttempts = 0;
                    } else {
                        logActivity('WebSocket connected', 'success');
                    }
                    updateConnectionBadge('connected');
                    lastHeartbeat = Date.now();
                    ws.send(JSON.stringify({ authorize: token }));
                };

                ws.onmessage = (msg) => {
                    lastHeartbeat = Date.now();
                    const data = JSON.parse(msg.data);
                    handleWebSocketMessage(data, resolve, reject);
                };

                ws.onerror = (error) => {
                    logActivity('WebSocket error', 'error');
                    updateConnectionBadge('disconnected');
                    reject(error);
                };

                ws.onclose = () => {
                    logActivity('WebSocket disconnected', 'error');
                    updateConnectionBadge('disconnected');
                    
                    Object.keys(markets).forEach(symbol => {
                        updateSubscriptionIndicator(symbol, 'disconnected');
                    });
                    
                    marketSubscriptions = {};
                    pendingSubscriptions = {};
                    
                    // Auto-reconnect logic
                    if (isLoggedIn && reconnectAttempts < maxReconnectAttempts) {
                        wasAutoTradingBeforeDisconnect = isAutoTrading;
                        reconnectAttempts++;
                        const delay = Math.min(1000 * Math.pow(2, reconnectAttempts - 1), 30000); // Exponential backoff, max 30s
                        
                        updateConnectionBadge('reconnecting');
                        logActivity(`Reconnection attempt ${reconnectAttempts}/${maxReconnectAttempts} in ${delay/1000}s...`, 'warning');
                        
                        reconnectTimeout = setTimeout(() => {
                            const savedToken = sessionStorage.getItem('derivToken');
                            if (savedToken) {
                                connectWebSocket(savedToken, true)
                                    .then(() => {
                                        logActivity('Reconnected successfully!', 'success');
                                        // Resume auto trading if it was active
                                        if (wasAutoTradingBeforeDisconnect && !isAutoTrading) {
                                            logActivity('Resuming auto trading...', 'info');
                                            setTimeout(() => startAutoTrading(), 1000);
                                        } else if (isAutoTrading) {
                                            subscribeToActiveMarkets();
                                        }
                                    })
                                    .catch(err => {
                                        logActivity(`Reconnection attempt ${reconnectAttempts} failed`, 'error');
                                    });
                            }
                        }, delay);
                    } else if (reconnectAttempts >= maxReconnectAttempts) {
                        logActivity('Max reconnection attempts reached. Please refresh the page or login again.', 'error');
                        reconnectAttempts = 0;
                    }
                };
            });
        }

        // Handle WebSocket messages
        function handleWebSocketMessage(data, resolve, reject) {
            if (data.error) {
                if (data.error.code !== 'AlreadySubscribed') {
                    logActivity('API Error: ' + data.error.message, 'error');
                    
                    if (data.echo_req && data.echo_req.ticks) {
                        const symbol = data.echo_req.ticks;
                        delete pendingSubscriptions[symbol];
                        updateSubscriptionIndicator(symbol, 'disconnected');
                    }
                }
                if (reject && data.error.code !== 'AlreadySubscribed') {
                    reject(new Error(data.error.message));
                }
                return;
            }

            if (data.msg_type === 'authorize') {
                accountInfo = {
                    type: data.authorize.account_list.find(a => a.loginid === data.authorize.loginid)?.is_virtual ? 'Demo' : 'Real',
                    currency: data.authorize.currency,
                    balance: data.authorize.balance,
                    loginid: data.authorize.loginid
                };

                document.getElementById('accountType').textContent = accountInfo.type;
                document.getElementById('accountCurrency').textContent = accountInfo.currency;
                document.getElementById('accountBalance').textContent = parseFloat(accountInfo.balance).toFixed(2);

                logActivity(`Logged in as ${accountInfo.loginid} (${accountInfo.type})`, 'success');
                
                ws.send(JSON.stringify({ balance: 1, subscribe: 1 }));

                if (resolve) resolve();
            }

            if (data.msg_type === 'balance') {
                accountInfo.balance = data.balance.balance;
                document.getElementById('accountBalance').textContent = parseFloat(accountInfo.balance).toFixed(2);
            }

            // Tick handler
            if (data.msg_type === 'tick' && data.tick) {
                const symbol = data.tick.symbol;
                if (!activeMarkets[symbol]) return;

                const epoch = data.tick.epoch;
                const quote = parseFloat(data.tick.quote);
                const now = Date.now();
                
                const calculatedOffset = now - (epoch * 1000);
                if (!isTimeSynced) {
                    serverTimeOffset = calculatedOffset;
                    isTimeSynced = true;
                } else {
                    serverTimeOffset = (serverTimeOffset * 0.9) + (calculatedOffset * 0.1);
                }

                const tickMinute = Math.floor(epoch / 60) * 60;

                if (currentMinute[symbol] === undefined) {
                    currentMinute[symbol] = tickMinute;
                    currentOHLC[symbol] = { open: quote, high: quote, low: quote, close: quote };
                }

                if (tickMinute > currentMinute[symbol]) {
                    finalizeCandle(symbol, tickMinute, quote);
                }

                if (currentOHLC[symbol]) {
                    currentOHLC[symbol].high = Math.max(currentOHLC[symbol].high, quote);
                    currentOHLC[symbol].low = Math.min(currentOHLC[symbol].low, quote);
                    currentOHLC[symbol].close = quote;
                }

                if (data.subscription && data.subscription.id && !marketSubscriptions[symbol]) {
                    marketSubscriptions[symbol] = data.subscription.id;
                    delete pendingSubscriptions[symbol];
                    updateSubscriptionIndicator(symbol, 'subscribed');
                    logActivity(`${markets[symbol]} subscribed successfully`, 'success');
                }
            }

            if (data.msg_type === 'proposal' && data.proposal) {
                const reqId = data.req_id;
                if (pendingProposals.has(reqId)) {
                    const proposalData = pendingProposals.get(reqId);
                    proposalData.resolve(data);
                    pendingProposals.delete(reqId);
                }
            }

            if (data.msg_type === 'buy') {
                if (data.buy && data.buy.contract_id) {
                    const proposalId = data.echo_req?.buy;
                    const tradeInfo = pendingTrades.get(proposalId);
                    
                    if (tradeInfo) {
                        pendingTrades.delete(proposalId);
                        pendingTrades.set(data.buy.contract_id, tradeInfo);
                    }
                    
                    ws.send(JSON.stringify({
                        proposal_open_contract: 1,
                        contract_id: data.buy.contract_id,
                        subscribe: 1
                    }));
                    
                    logActivity(`Trade opened: Contract ID ${data.buy.contract_id}`, 'success');
                }
            }

            if (data.msg_type === 'proposal_open_contract') {
                handleTradeResult(data.proposal_open_contract);
            }

            if (data.msg_type === 'forget') {
                if (data.forget) {
                    logActivity(`Unsubscribed from subscription ID: ${data.forget}`, 'info');
                }
            }

            if (data.msg_type === 'ping') {
                ws.send(JSON.stringify({ ping: 1 }));
            }
        }

        // Handle trade result
        function handleTradeResult(contract) {
            if (['won', 'lost', 'sold'].includes(contract.status)) {
                
                if (tradeHistory.some(t => t.id === contract.contract_id)) {
                    return;
                }

                const profit = parseFloat(contract.profit || 0);
                const isWin = profit > 0;

                tradeStats.total++;
                if (isWin) tradeStats.wins++;
                else tradeStats.losses++;
                tradeStats.profitLoss += profit;

                const trade = {
                    id: contract.contract_id,
                    time: new Date().toLocaleTimeString(),
                    market: markets[contract.underlying] || contract.underlying || 'Unknown',
                    type: contract.contract_type || 'Unknown',
                    stake: parseFloat(contract.buy_price || 0).toFixed(2),
                    result: profit.toFixed(2),
                    isWin: isWin
                };

                if (!Array.isArray(tradeHistory)) tradeHistory = [];
                tradeHistory.unshift(trade);
                
                if (tradeHistory.length > 100) tradeHistory.pop();

                updateStats();
                updateTradeHistoryTable();
                saveSettings();

                logActivity(`Trade closed: ${trade.market} - ${trade.type} - P/L: ${trade.result}`, isWin ? 'success' : 'error');

                const stopLoss = parseFloat(document.getElementById('stopLoss').value);
                const takeProfit = parseFloat(document.getElementById('takeProfit').value);

                if (stopLoss > 0 && Math.abs(tradeStats.profitLoss) >= stopLoss && tradeStats.profitLoss < 0) {
                    logActivity(`Stop loss reached: ${tradeStats.profitLoss.toFixed(2)}`, 'error');
                    stopAutoTrading();
                }

                if (takeProfit > 0 && tradeStats.profitLoss >= takeProfit) {
                    logActivity(`Take profit reached: ${tradeStats.profitLoss.toFixed(2)}`, 'success');
                    stopAutoTrading();
                }

                if (pendingTrades.has(contract.contract_id)) {
                    pendingTrades.delete(contract.contract_id);
                }
            }
        }

        // Login
        document.getElementById('loginBtn').addEventListener('click', async () => {
            const token = document.getElementById('apiToken').value.trim();
            if (!token) {
                logActivity('Please enter API token', 'error');
                return;
            }

            document.getElementById('loginBtn').disabled = true;
            document.getElementById('loginBtn').textContent = 'Connecting...';

            try {
                await connectWebSocket(token);
                isLoggedIn = true;
                reconnectAttempts = 0;
                
                document.getElementById('loginSection').classList.add('hidden');
                document.getElementById('accountInfo').classList.remove('hidden');
                document.getElementById('timerDisplay').classList.remove('hidden');
                document.getElementById('autoTradeBtn').disabled = false;
                document.getElementById('reverseModeBtn').disabled = false;

                saveSettings();
                startSessionTimer();
                logActivity('Login successful', 'success');
            } catch (error) {
                logActivity('Login failed: ' + error.message, 'error');
                document.getElementById('loginBtn').disabled = false;
                document.getElementById('loginBtn').textContent = 'Login';
                updateConnectionBadge('disconnected');
            }
        });

        // Logout
        document.getElementById('logoutBtn').addEventListener('click', () => {
            if (isAutoTrading) {
                stopAutoTrading();
            }

            if (ws) {
                ws.close();
                ws = null;
            }

            if (reconnectTimeout) {
                clearTimeout(reconnectTimeout);
                reconnectTimeout = null;
            }

            isLoggedIn = false;
            reconnectAttempts = 0;
            stopSessionTimer();
            updateConnectionBadge('disconnected');

            document.getElementById('apiToken').value = '';
            sessionStorage.removeItem('derivToken');

            document.getElementById('loginSection').classList.remove('hidden');
            document.getElementById('accountInfo').classList.add('hidden');
            document.getElementById('timerDisplay').classList.add('hidden');
            document.getElementById('autoTradeBtn').disabled = true;
            document.getElementById('reverseModeBtn').disabled = true;
            document.getElementById('loginBtn').disabled = false;
            document.getElementById('loginBtn').textContent = 'Login';

            logActivity('Logged out successfully - Token cleared', 'success');
        });

        // Session timer
        function startSessionTimer() {
            sessionStartTime = Date.now();
            sessionTimer = setInterval(() => {
                const elapsed = Date.now() - sessionStartTime;
                const hours = Math.floor(elapsed / 3600000);
                const minutes = Math.floor((elapsed % 3600000) / 60000);
                const seconds = Math.floor((elapsed % 60000) / 1000);
                
                document.getElementById('timerValue').textContent = 
                    `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            }, 1000);
        }

        function stopSessionTimer() {
            if (sessionTimer) {
                clearInterval(sessionTimer);
                sessionTimer = null;
            }
            document.getElementById('timerValue').textContent = '00:00:00';
        }

        // Subscribe to market
        function subscribeToMarket(symbol) {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                logActivity('Cannot subscribe: WebSocket not connected', 'error');
                return;
            }

            if (marketSubscriptions[symbol]) {
                logActivity(`Already subscribed to ${markets[symbol]}`, 'info');
                updateSubscriptionIndicator(symbol, 'subscribed');
                return;
            }

            if (pendingSubscriptions[symbol]) {
                logActivity(`Already subscribing to ${markets[symbol]}`, 'info');
                return;
            }

            pendingSubscriptions[symbol] = true;
            updateSubscriptionIndicator(symbol, 'subscribing');

            const subscribeMsg = {
                ticks: symbol,
                subscribe: 1
            };

            ws.send(JSON.stringify(subscribeMsg));
            logActivity(`Subscribing to ${markets[symbol]}...`, 'info');

            setTimeout(() => {
                if (pendingSubscriptions[symbol] && !marketSubscriptions[symbol]) {
                    delete pendingSubscriptions[symbol];
                    updateSubscriptionIndicator(symbol, 'disconnected');
                    logActivity(`Subscription timeout for ${markets[symbol]}`, 'error');
                }
            }, 10000);
        }

        function unsubscribeFromMarket(symbol) {
            if (!ws || ws.readyState !== WebSocket.OPEN) return;

            if (marketSubscriptions[symbol]) {
                ws.send(JSON.stringify({ forget: marketSubscriptions[symbol] }));
                delete marketSubscriptions[symbol];
                candleData[symbol] = [];
                currentOHLC[symbol] = undefined;
                currentMinute[symbol] = undefined;
                tradedCandles[symbol].clear();
                rsiCache[symbol] = {};
                updateSubscriptionIndicator(symbol, 'disconnected');
                logActivity(`Unsubscribed from ${markets[symbol]}`);
            }

            if (pendingSubscriptions[symbol]) {
                delete pendingSubscriptions[symbol];
                updateSubscriptionIndicator(symbol, 'disconnected');
            }
            
            updateCandleCounter();
        }

        // Subscribe to all active markets
        function subscribeToActiveMarkets() {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                logActivity('Cannot subscribe: WebSocket not connected', 'error');
                return;
            }

            let subscribeCount = 0;
            Object.keys(activeMarkets).forEach(symbol => {
                if (activeMarkets[symbol]) {
                    subscribeToMarket(symbol);
                    subscribeCount++;
                }
            });

            logActivity(`Subscribing to ${subscribeCount} active markets...`, 'info');
        }

        // Unsubscribe from all markets
        function unsubscribeFromAllMarkets() {
            Object.keys(marketSubscriptions).forEach(symbol => {
                unsubscribeFromMarket(symbol);
            });
            Object.keys(pendingSubscriptions).forEach(symbol => {
                delete pendingSubscriptions[symbol];
                updateSubscriptionIndicator(symbol, 'disconnected');
            });
        }

        // Calculate RSI with caching
        function calculateRSI(data, period) {
            if (data.length < period + 1) return null;

            const cacheKey = `${data.length}_${period}`;
            
            const symbol = Object.keys(candleData).find(s => candleData[s] === data);
            if (symbol && rsiCache[symbol] && rsiCache[symbol][cacheKey] !== undefined) {
                return rsiCache[symbol][cacheKey];
            }

            let gains = 0;
            let losses = 0;

            // Calculate initial average gain and loss
            for (let i = 1; i <= period; i++) {
                const change = data[i].close - data[i - 1].close;
                if (change > 0) {
                    gains += change;
                } else {
                    losses += Math.abs(change);
                }
            }

            let avgGain = gains / period;
            let avgLoss = losses / period;

            // Calculate subsequent values using smoothing
            for (let i = period + 1; i < data.length; i++) {
                const change = data[i].close - data[i - 1].close;
                if (change > 0) {
                    avgGain = (avgGain * (period - 1) + change) / period;
                    avgLoss = (avgLoss * (period - 1)) / period;
                } else {
                    avgGain = (avgGain * (period - 1)) / period;
                    avgLoss = (avgLoss * (period - 1) + Math.abs(change)) / period;
                }
            }

            const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
            const rsi = 100 - (100 / (1 + rs));

            // Cache the result
            if (symbol) {
                if (!rsiCache[symbol]) rsiCache[symbol] = {};
                rsiCache[symbol][cacheKey] = rsi;
            }

            return rsi;
        }

        // Check Trend Structure (HH+HL for uptrend, LL+LH for downtrend)
        function checkTrendStructure(data, lookback) {
            if (data.length < lookback + 2) return null;

            const recentCandles = data.slice(-lookback);
            
            // Check for Higher Highs + Higher Lows (Uptrend)
            let isUptrend = true;
            for (let i = 1; i < recentCandles.length; i++) {
                if (recentCandles[i].high <= recentCandles[i - 1].high || 
                    recentCandles[i].low <= recentCandles[i - 1].low) {
                    isUptrend = false;
                    break;
                }
            }

            if (isUptrend) return 'uptrend'; // HH + HL

            // Check for Lower Lows + Lower Highs (Downtrend)
            let isDowntrend = true;
            for (let i = 1; i < recentCandles.length; i++) {
                if (recentCandles[i].low >= recentCandles[i - 1].low || 
                    recentCandles[i].high >= recentCandles[i - 1].high) {
                    isDowntrend = false;
                    break;
                }
            }

            if (isDowntrend) return 'downtrend'; // LL + LH

            return null; // No clear trend structure
        }

        // Check for trading signals with all filters
        function checkForSignals(symbol) {
            const rsiFilter = document.getElementById('rsiFilter').checked;
            const trendStructureFilter = document.getElementById('trendStructureFilter').checked;
            const rsiPeriod = parseInt(document.getElementById('rsiPeriod').value);
            const trendLookback = parseInt(document.getElementById('trendLookback').value);
            
            let requiredCandles = 3;
            if (rsiFilter) {
                requiredCandles = Math.max(requiredCandles, rsiPeriod + 2);
            }
            if (trendStructureFilter) {
                requiredCandles = Math.max(requiredCandles, trendLookback + 2);
            }
            
            if (candleData[symbol].length < requiredCandles) return;

            const candles = candleData[symbol];
            
            const lastCandle = candles[candles.length - 1];
            const prevCandle = candles[candles.length - 2];

            if (!lastCandle || !prevCandle) return;

            const candle_start_time = lastCandle.time;
            if (candle_start_time < activation_time) {
                return;
            }

            const candleKey = `${lastCandle.time}`;
            if (tradedCandles[symbol].has(candleKey)) {
                return;
            }

            const zeroClosingFilter = document.getElementById('zeroClosingFilter').checked;
            const ignoreHeightFilter = document.getElementById('ignoreHeightFilter').checked;
            const lengthFilter = document.getElementById('lengthFilter').checked;
            const reverseCandleFilter = document.getElementById('reverseCandleFilter').checked;
            const minLowerWickBuy = parseFloat(document.getElementById('minLowerWickBuy').value) / 100;
            const minUpperWickSell = parseFloat(document.getElementById('minUpperWickSell').value) / 100;
            const minUpperWickBuy = parseFloat(document.getElementById('minUpperWickBuy').value) / 100;
            const minLowerWickSell = parseFloat(document.getElementById('minLowerWickSell').value) / 100;
            const matchingDiffBuy = parseFloat(document.getElementById('matchingDiffBuy').value) / 100;
            const matchingDiffSell = parseFloat(document.getElementById('matchingDiffSell').value) / 100;

            let rsiValue = null;
            let trendStructure = null;

            if (rsiFilter) {
                rsiValue = calculateRSI(candles.slice(0, -1), rsiPeriod);
            }

            if (trendStructureFilter) {
                trendStructure = checkTrendStructure(candles.slice(0, -1), trendLookback);
            }

            const buySignal = checkTweezersBottom(prevCandle, lastCandle, zeroClosingFilter, ignoreHeightFilter, lengthFilter, reverseCandleFilter, minLowerWickBuy, minUpperWickBuy, matchingDiffBuy);
            if (buySignal) {
                let shouldTrade = true;
                let filterInfo = [];

                // RSI Filter Check
                if (rsiFilter && rsiValue !== null) {
                    const rsiOversold = parseFloat(document.getElementById('rsiOversold').value);
                    if (rsiValue >= rsiOversold) {
                        shouldTrade = false;
                    } else {
                        filterInfo.push(`RSI: ${rsiValue.toFixed(2)} < ${rsiOversold}`);
                    }
                }

                // Trend Structure Filter Check (Sell at HH+HL uptrend)
                if (trendStructureFilter && trendStructure !== null) {
                    if (trendStructure !== 'downtrend') {
                        shouldTrade = false;
                    } else {
                        filterInfo.push(`Trend: LL+LH`);
                    }
                }

                if (shouldTrade) {
                    const tradeType = isReverseMode ? 'PUT' : 'CALL';
                    const patternName = reverseCandleFilter ? 'Reverse Tweezers Bottom' : 'Tweezers Bottom';
                    const signalText = isReverseMode ? `${patternName} SELL (REVERSED)` : `${patternName} BUY`;
                    const info = filterInfo.length > 0 ? ` [${filterInfo.join(', ')}]` : '';
                    addSignal(symbol, `${signalText}${info}`);
                    executeTrade(symbol, tradeType, candleKey);
                }
            }

            const sellSignal = checkTweezersTop(prevCandle, lastCandle, zeroClosingFilter, ignoreHeightFilter, lengthFilter, reverseCandleFilter, minUpperWickSell, minLowerWickSell, matchingDiffSell);
            if (sellSignal) {
                let shouldTrade = true;
                let filterInfo = [];

                // RSI Filter Check
                if (rsiFilter && rsiValue !== null) {
                    const rsiOverbought = parseFloat(document.getElementById('rsiOverbought').value);
                    if (rsiValue <= rsiOverbought) {
                        shouldTrade = false;
                    } else {
                        filterInfo.push(`RSI: ${rsiValue.toFixed(2)} > ${rsiOverbought}`);
                    }
                }

                // Trend Structure Filter Check (Buy at LL+LH downtrend)
                if (trendStructureFilter && trendStructure !== null) {
                    if (trendStructure !== 'uptrend') {
                        shouldTrade = false;
                    } else {
                        filterInfo.push(`Trend: HH+HL`);
                    }
                }

                if (shouldTrade) {
                    const tradeType = isReverseMode ? 'CALL' : 'PUT';
                    const patternName = reverseCandleFilter ? 'Reverse Tweezers Top' : 'Tweezers Top';
                    const signalText = isReverseMode ? `${patternName} BUY (REVERSED)` : `${patternName} SELL`;
                    const info = filterInfo.length > 0 ? ` [${filterInfo.join(', ')}]` : '';
                    addSignal(symbol, `${signalText}${info}`);
                    executeTrade(symbol, tradeType, candleKey);
                }
            }
        }

        // Check Tweezers Bottom with all filters
        function checkTweezersBottom(candle1, candle2, zeroClosing, ignoreHeight, lengthFilter, reverseCandle, minLowerWickPercent, minUpperWickPercent, matchingDiff) {
            const isCandle1Red = candle1.close < candle1.open;
            const isCandle1Green = candle1.close > candle1.open;
            
            if (reverseCandle) {
                if (!isCandle1Green) return false;
            } else {
                if (!isCandle1Red) return false;
            }

            const candle1Range = candle1.high - candle1.low;
            if (candle1Range === 0) return false;

            const candle1LowerWick = Math.min(candle1.open, candle1.close) - candle1.low;
            const candle1UpperWick = candle1.high - Math.max(candle1.open, candle1.close);

            if (candle1LowerWick / candle1Range < minLowerWickPercent) return false;

            if (zeroClosing) {
                if (candle1UpperWick !== 0) return false;
            } else {
                if (candle1UpperWick / candle1Range > minUpperWickPercent) return false;
            }

            const isCandle2Green = candle2.close > candle2.open;
            const isCandle2Red = candle2.close < candle2.open;
            
            if (reverseCandle) {
                if (!isCandle2Red) return false;
            } else {
                if (!isCandle2Green) return false;
            }

            const candle2Range = candle2.high - candle2.low;
            if (candle2Range === 0) return false;

            const candle2LowerWick = Math.min(candle2.open, candle2.close) - candle2.low;
            const candle2UpperWick = candle2.high - Math.max(candle2.open, candle2.close);

            if (candle2LowerWick / candle2Range < minLowerWickPercent) return false;

            if (zeroClosing) {
                if (candle2UpperWick !== 0) return false;
            } else {
                if (candle2UpperWick / candle2Range > minUpperWickPercent) return false;
            }

            const lowDiff = Math.abs(candle1.low - candle2.low) / candle1.low;
            if (lowDiff > matchingDiff) return false;

            if (ignoreHeight) {
                return true;
            } else if (lengthFilter) {
                const candle1UpperLength = candle1.high - candle1.low;
                const candle2UpperLength = candle2.high - candle2.low;
                
                if (candle2UpperLength > candle1UpperLength) return false;
                
                if (candle2.close > candle1.high) return false;
            } else {
                if (candle2.close < candle1.high) return false;
            }

            return true;
        }

        // Check Tweezers Top with all filters
        function checkTweezersTop(candle1, candle2, zeroClosing, ignoreHeight, lengthFilter, reverseCandle, minUpperWickPercent, minLowerWickPercent, matchingDiff) {
            const isCandle1Green = candle1.close > candle1.open;
            const isCandle1Red = candle1.close < candle1.open;
            
            if (reverseCandle) {
                if (!isCandle1Red) return false;
            } else {
                if (!isCandle1Green) return false;
            }

            const candle1Range = candle1.high - candle1.low;
            if (candle1Range === 0) return false;

            const candle1UpperWick = candle1.high - Math.max(candle1.open, candle1.close);
            const candle1LowerWick = Math.min(candle1.open, candle1.close) - candle1.low;

            if (candle1UpperWick / candle1Range < minUpperWickPercent) return false;

            if (zeroClosing) {
                if (candle1LowerWick !== 0) return false;
            } else {
                if (candle1LowerWick / candle1Range > minLowerWickPercent) return false;
            }

            const isCandle2Red = candle2.close < candle2.open;
            const isCandle2Green = candle2.close > candle2.open;
            
            if (reverseCandle) {
                if (!isCandle2Green) return false;
            } else {
                if (!isCandle2Red) return false;
            }

            const candle2Range = candle2.high - candle2.low;
            if (candle2Range === 0) return false;

            const candle2UpperWick = candle2.high - Math.max(candle2.open, candle2.close);
            const candle2LowerWick = Math.min(candle2.open, candle2.close) - candle2.low;

            if (candle2UpperWick / candle2Range < minUpperWickPercent) return false;

            if (zeroClosing) {
                if (candle2LowerWick !== 0) return false;
            } else {
                if (candle2LowerWick / candle2Range > minLowerWickPercent) return false;
            }

            const highDiff = Math.abs(candle1.high - candle2.high) / candle1.high;
            if (highDiff > matchingDiff) return false;

            if (ignoreHeight) {
                return true;
            } else if (lengthFilter) {
                const candle1LowerLength = candle1.high - candle1.low;
                const candle2LowerLength = candle2.high - candle2.low;
                
                if (candle2LowerLength > candle1LowerLength) return false;
                
                if (candle2.close < candle1.low) return false;
            } else {
                if (candle2.close > candle1.low) return false;
            }

            return true;
        }

        // Add signal to monitor
        let signalCounter = 0;
        function addSignal(symbol, pattern) {
            const container = document.getElementById('signalsContainer');
            
            if (isFirstSignal) {
                container.innerHTML = '';
                isFirstSignal = false;
            }

            const signalId = `signal-${signalCounter++}`;
            
            const time = new Date().toLocaleTimeString();
            const signalDiv = document.createElement('div');
            signalDiv.className = 'signal-item';
            signalDiv.id = signalId;
            signalDiv.innerHTML = `<div class="signal-text">[${time}] ${markets[symbol]} - ${pattern}</div>`;
            
            container.insertBefore(signalDiv, container.firstChild);
            
            while (container.children.length > 50) {
                container.removeChild(container.lastChild);
            }

            return signalId;
        }

        // Execute trade
        async function executeTrade(symbol, type, candleKey) {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                logActivity('Cannot execute trade: WebSocket not connected', 'error');
                return;
            }

            const stake = parseFloat(document.getElementById('stakeAmount').value);
            const durationType = document.getElementById('durationType').value;
            const durationValue = parseInt(document.getElementById('durationValue').value);

            const reqId = ++requestIdCounter;

            const proposal = {
                proposal: 1,
                amount: stake,
                basis: 'stake',
                contract_type: type,
                currency: accountInfo.currency,
                duration: durationValue,
                duration_unit: durationType,
                symbol: symbol,
                req_id: reqId
            };

            try {
                ws.send(JSON.stringify(proposal));
                
                const proposalResponse = await new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => {
                        pendingProposals.delete(reqId);
                        reject(new Error('Proposal timeout'));
                    }, 5000);
                    
                    pendingProposals.set(reqId, { resolve, reject, timeout });
                });

                if (pendingProposals.has(reqId)) {
                    clearTimeout(pendingProposals.get(reqId).timeout);
                    pendingProposals.delete(reqId);
                }

                if (proposalResponse.proposal) {
                    const proposalId = proposalResponse.proposal.id;
                    const tradeInfo = {
                        symbol: symbol,
                        type: type,
                        stake: stake,
                        candle_time: candleKey
                    };
                    
                    pendingTrades.set(proposalId, tradeInfo);
                    
                    ws.send(JSON.stringify({
                        buy: proposalId,
                        price: stake
                    }));

                    tradedCandles[symbol].add(candleKey);

                    logActivity(`Trade executed: ${type} on ${markets[symbol]} - Stake: ${stake}`, 'success');
                }
            } catch (error) {
                logActivity(`Trade execution failed: ${error.message}`, 'error');
            }
        }

        // Update statistics
        function updateStats() {
            document.getElementById('totalTrades').textContent = tradeStats.total;
            document.getElementById('totalWins').textContent = tradeStats.wins;
            document.getElementById('totalLosses').textContent = tradeStats.losses;
            
            const plElement = document.getElementById('profitLoss');
            plElement.textContent = tradeStats.profitLoss.toFixed(2);
            plElement.className = 'stat-value ' + (tradeStats.profitLoss >= 0 ? 'profit' : 'loss');
        }

        // Update trade history table
        function updateTradeHistoryTable() {
            const tbody = document.getElementById('historyTableBody');
            
            if (tradeHistory.length === 0) {
                tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; color: #8899aa;">No trades yet</td></tr>';
                updateTradeCountDisplay();
                return;
            }

            tbody.innerHTML = '';
            
            const displayCount = Math.min(tradeHistory.length, 100);
            for (let i = 0; i < displayCount; i++) {
                const trade = tradeHistory[i];
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${i + 1}</td>
                    <td>${trade.time}</td>
                    <td>${trade.market}</td>
                    <td>${trade.type}</td>
                    <td>${trade.stake}</td>
                    <td class="${trade.isWin ? 'result-win' : 'result-loss'}">${trade.result}</td>
                `;
                tbody.appendChild(row);
            }
            
            updateTradeCountDisplay();
        }

        // Start auto trading
        function startAutoTrading() {
            if (!isLoggedIn) {
                logActivity('Please login first', 'error');
                return;
            }

            if (!ws || ws.readyState !== WebSocket.OPEN) {
                logActivity('WebSocket not connected. Please check connection.', 'error');
                return;
            }

            isAutoTrading = true;
            isFirstSignal = true;
            
            activation_time = Math.floor(Date.now() / 1000);
            
            Object.keys(markets).forEach(symbol => {
                candleData[symbol] = [];
                currentOHLC[symbol] = undefined;
                currentMinute[symbol] = undefined;
                tradedCandles[symbol].clear();
                rsiCache[symbol] = {};
            });
            
            document.getElementById('autoTradeBtn').textContent = 'Stop Auto Trade';
            document.getElementById('autoTradeBtn').className = 'btn btn-danger';
            
            const statusText = document.getElementById('statusText');
            const statusDot = document.getElementById('statusDot');
            statusText.textContent = 'Bot Active - Analyzing Markets';
            statusText.className = 'status-text active';
            statusDot.className = 'pulse-dot active';

            const container = document.getElementById('signalsContainer');
            container.innerHTML = '<div class="signal-item"><div class="signal-text">Bot activated. Monitoring markets for signals...</div></div>';

            const rsiFilter = document.getElementById('rsiFilter').checked;
            const trendStructureFilter = document.getElementById('trendStructureFilter').checked;
            const rsiPeriod = parseInt(document.getElementById('rsiPeriod').value);
            const trendLookback = parseInt(document.getElementById('trendLookback').value);
            
            let requiredCandles = 3;
            if (rsiFilter) {
                requiredCandles = Math.max(requiredCandles, rsiPeriod + 2);
            }
            if (trendStructureFilter) {
                requiredCandles = Math.max(requiredCandles, trendLookback + 2);
            }
            
            logActivity('Auto trading started', 'success');
            logActivity(`Activation time set: ${new Date(activation_time * 1000).toLocaleTimeString()}`, 'info');
            logActivity(`Reverse Mode: ${isReverseMode ? 'ON' : 'OFF'}`, isReverseMode ? 'success' : 'info');
            
            // Log active filters
            const activeFilters = [];
            if (rsiFilter) {
                const oversold = document.getElementById('rsiOversold').value;
                const overbought = document.getElementById('rsiOverbought').value;
                activeFilters.push(`RSI Filter (${rsiPeriod}) - Buy<${oversold}, Sell>${overbought}`);
            }
            if (trendStructureFilter) activeFilters.push(`Trend Structure (${trendLookback} candles) - Sell@HH+HL, Buy@LL+LH`);
            if (document.getElementById('zeroClosingFilter').checked) activeFilters.push('Zero Closing (Perfect 0)');
            if (document.getElementById('ignoreHeightFilter').checked) activeFilters.push('Ignore Height');
            if (document.getElementById('lengthFilter').checked) activeFilters.push('Length Filter');
            if (document.getElementById('reverseCandleFilter').checked) activeFilters.push('Reverse Candle (Green‚ÜíRed for Buy, Red‚ÜíGreen for Sell)');
            
            if (activeFilters.length > 0) {
                logActivity(`Active filters: ${activeFilters.join(', ')}`, 'info');
            } else {
                logActivity('No filters active', 'info');
            }
            
            logActivity(`Waiting for ${requiredCandles} candles before analyzing`, 'info');

            updateCandleCounter();
            subscribeToActiveMarkets();

            // Watchdog Timer
            if (candleWatchdogTimer) clearInterval(candleWatchdogTimer);
            
            candleWatchdogTimer = setInterval(() => {
                if (!isTimeSynced) return;
                
                const estimatedServerTime = Date.now() - serverTimeOffset;
                const currentServerMinute = Math.floor(estimatedServerTime / 1000 / 60) * 60;

                Object.keys(activeMarkets).forEach(symbol => {
                    if (!activeMarkets[symbol] || !marketSubscriptions[symbol]) return;
                    if (currentMinute[symbol] === undefined) return;

                    if (currentServerMinute > currentMinute[symbol]) {
                        const lastPrice = currentOHLC[symbol].close;
                        finalizeCandle(symbol, currentServerMinute, lastPrice);
                    }
                });
            }, 200);

            saveSettings();
        }

        // Stop auto trading
        function stopAutoTrading() {
            isAutoTrading = false;
            activation_time = 0;
            
            document.getElementById('autoTradeBtn').textContent = 'Start Auto Trade';
            document.getElementById('autoTradeBtn').className = 'btn btn-success';
            
            const statusText = document.getElementById('statusText');
            const statusDot = document.getElementById('statusDot');
            statusText.textContent = 'Bot Inactive';
            statusText.className = 'status-text';
            statusDot.className = 'pulse-dot';

            logActivity('Auto trading stopped', 'error');

            unsubscribeFromAllMarkets();

            const container = document.getElementById('signalsContainer');
            container.innerHTML = '<div class="signal-item"><div class="signal-text">Waiting for bot activation...</div></div>';
            
            document.getElementById('candleCounter').classList.add('hidden');
            
            if (candleWatchdogTimer) {
                clearInterval(candleWatchdogTimer);
                candleWatchdogTimer = null;
            }

            saveSettings();
        }

        // Update reverse mode button
        function updateReverseModeButton() {
            const btn = document.getElementById('reverseModeBtn');
            if (isReverseMode) {
                btn.textContent = 'Reverse Mode: ON';
                btn.className = 'btn btn-warning';
            } else {
                btn.textContent = 'Reverse Mode: OFF';
                btn.className = 'btn btn-warning';
            }
        }

        // Auto trade button
        document.getElementById('autoTradeBtn').addEventListener('click', () => {
            if (isAutoTrading) {
                stopAutoTrading();
            } else {
                startAutoTrading();
            }
        });

        // Reverse mode button
        document.getElementById('reverseModeBtn').addEventListener('click', () => {
            isReverseMode = !isReverseMode;
            updateReverseModeButton();
            updateReverseModeIndicator();
            saveSettings();
            
            if (isReverseMode) {
                logActivity('Reverse Mode ENABLED: Buy signals will execute Sell, Sell signals will execute Buy', 'success');
            } else {
                logActivity('Reverse Mode DISABLED: Normal trading mode', 'info');
            }
        });

        // Clear history button
        document.getElementById('clearHistoryBtn').addEventListener('click', () => {
            if (confirm('Are you sure you want to clear trade history?')) {
                tradeHistory = [];
                tradeStats = { total: 0, wins: 0, losses: 0, profitLoss: 0 };
                updateStats();
                updateTradeHistoryTable();
                saveSettings();
                logActivity('Trade history cleared', 'success');
            }
        });

        // Filter change listeners
        document.getElementById('rsiFilter').addEventListener('change', () => {
            const enabled = document.getElementById('rsiFilter').checked;
            const rsiPeriod = document.getElementById('rsiPeriod').value;
            const oversold = document.getElementById('rsiOversold').value;
            const overbought = document.getElementById('rsiOverbought').value;
            logActivity(`RSI filter ${enabled ? `enabled (Period: ${rsiPeriod}, Buy<${oversold}, Sell>${overbought})` : 'disabled'}`);
            if (isAutoTrading) {
                updateCandleCounter();
            }
            saveSettings();
        });

        document.getElementById('trendStructureFilter').addEventListener('change', () => {
            const enabled = document.getElementById('trendStructureFilter').checked;
            const lookback = document.getElementById('trendLookback').value;
            logActivity(`Trend Structure filter ${enabled ? `enabled (Lookback: ${lookback} candles, Sell@HH+HL, Buy@LL+LH)` : 'disabled'}`);
            if (isAutoTrading) {
                updateCandleCounter();
            }
            saveSettings();
        });

        document.getElementById('zeroClosingFilter').addEventListener('change', () => {
            const enabled = document.getElementById('zeroClosingFilter').checked;
            logActivity(`Zero closing filter (Perfect 0) ${enabled ? 'enabled' : 'disabled'}`);
            saveSettings();
        });

        document.getElementById('ignoreHeightFilter').addEventListener('change', () => {
            const enabled = document.getElementById('ignoreHeightFilter').checked;
            logActivity(`Ignore height filter ${enabled ? 'enabled' : 'disabled'}`);
            checkFilterConflicts();
            saveSettings();
        });

        document.getElementById('lengthFilter').addEventListener('change', () => {
            const enabled = document.getElementById('lengthFilter').checked;
            logActivity(`Length filter ${enabled ? 'enabled' : 'disabled'}`);
            if (enabled) {
                logActivity('Length Filter: Confirmation candle height must be ‚â§ first candle height', 'info');
            }
            checkFilterConflicts();
            saveSettings();
        });

        document.getElementById('reverseCandleFilter').addEventListener('change', () => {
            const enabled = document.getElementById('reverseCandleFilter').checked;
            logActivity(`Reverse Candle filter ${enabled ? 'enabled' : 'disabled'}`);
            if (enabled) {
                logActivity('Reverse Candle: Buy = Green‚ÜíRed (Matching Lows), Sell = Red‚ÜíGreen (Matching Highs)', 'info');
            } else {
                logActivity('Normal Candle: Buy = Red‚ÜíGreen (Matching Lows), Sell = Green‚ÜíRed (Matching Highs)', 'info');
            }
            saveSettings();
        });

        document.getElementById('stakeAmount').addEventListener('change', () => {
            logActivity(`Stake amount updated to ${document.getElementById('stakeAmount').value}`);
            saveSettings();
        });

        document.getElementById('stopLoss').addEventListener('change', () => {
            logActivity(`Stop loss updated to ${document.getElementById('stopLoss').value}`);
            saveSettings();
        });

        document.getElementById('takeProfit').addEventListener('change', () => {
            logActivity(`Take profit updated to ${document.getElementById('takeProfit').value}`);
            saveSettings();
        });

        document.getElementById('rsiPeriod').addEventListener('change', () => {
            const rsiPeriod = document.getElementById('rsiPeriod').value;
            logActivity(`RSI period updated to ${rsiPeriod}`);
            
            Object.keys(rsiCache).forEach(symbol => {
                rsiCache[symbol] = {};
            });
            
            if (isAutoTrading && document.getElementById('rsiFilter').checked) {
                updateCandleCounter();
            }
            saveSettings();
        });

        document.getElementById('rsiOversold').addEventListener('change', () => {
            logActivity(`RSI oversold level updated to ${document.getElementById('rsiOversold').value}`);
            saveSettings();
        });

        document.getElementById('rsiOverbought').addEventListener('change', () => {
            logActivity(`RSI overbought level updated to ${document.getElementById('rsiOverbought').value}`);
            saveSettings();
        });

        document.getElementById('trendLookback').addEventListener('change', () => {
            logActivity(`Trend lookback updated to ${document.getElementById('trendLookback').value} candles`);
            if (isAutoTrading && document.getElementById('trendStructureFilter').checked) {
                updateCandleCounter();
            }
            saveSettings();
        });

        document.getElementById('durationType').addEventListener('change', () => {
            logActivity(`Duration type updated to ${document.getElementById('durationType').value}`);
            saveSettings();
        });

        document.getElementById('durationValue').addEventListener('change', () => {
            logActivity(`Duration value updated to ${document.getElementById('durationValue').value}`);
            saveSettings();
        });

        document.getElementById('minLowerWickBuy').addEventListener('change', () => {
            logActivity(`Min lower wick (Buy) updated to ${document.getElementById('minLowerWickBuy').value}%`);
            saveSettings();
        });

        document.getElementById('minUpperWickSell').addEventListener('change', () => {
            logActivity(`Min upper wick (Sell) updated to ${document.getElementById('minUpperWickSell').value}%`);
            saveSettings();
        });

        document.getElementById('minUpperWickBuy').addEventListener('change', () => {
            logActivity(`Min upper wick (Buy) updated to ${document.getElementById('minUpperWickBuy').value}%`);
            saveSettings();
        });

        document.getElementById('minLowerWickSell').addEventListener('change', () => {
            logActivity(`Min lower wick (Sell) updated to ${document.getElementById('minLowerWickSell').value}%`);
            saveSettings();
        });

        document.getElementById('matchingDiffBuy').addEventListener('change', () => {
            logActivity(`Matching diff (Buy) updated to ${document.getElementById('matchingDiffBuy').value}%`);
            saveSettings();
        });

        document.getElementById('matchingDiffSell').addEventListener('change', () => {
            logActivity(`Matching diff (Sell) updated to ${document.getElementById('matchingDiffSell').value}%`);
            saveSettings();
        });

        // Validate input fields
        function validateInputs() {
            const stakeAmount = parseFloat(document.getElementById('stakeAmount').value);
            const stopLoss = parseFloat(document.getElementById('stopLoss').value);
            const takeProfit = parseFloat(document.getElementById('takeProfit').value);
            const rsiPeriod = parseInt(document.getElementById('rsiPeriod').value);
            const rsiOversold = parseInt(document.getElementById('rsiOversold').value);
            const rsiOverbought = parseInt(document.getElementById('rsiOverbought').value);
            const trendLookback = parseInt(document.getElementById('trendLookback').value);
            const durationValue = parseInt(document.getElementById('durationValue').value);

            if (stakeAmount < 0.35) {
                logActivity('Stake amount must be at least 0.35', 'error');
                document.getElementById('stakeAmount').value = 0.35;
                return false;
            }

            if (stopLoss < 0) {
                logActivity('Stop loss cannot be negative', 'error');
                document.getElementById('stopLoss').value = 0;
                return false;
            }

            if (takeProfit < 0) {
                logActivity('Take profit cannot be negative', 'error');
                document.getElementById('takeProfit').value = 0;
                return false;
            }

            if (rsiPeriod < 5 || rsiPeriod > 50) {
                logActivity('RSI period must be between 5 and 50', 'error');
                document.getElementById('rsiPeriod').value = 14;
                return false;
            }

            if (rsiOversold < 10 || rsiOversold > 50) {
                logActivity('RSI oversold must be between 10 and 50', 'error');
                document.getElementById('rsiOversold').value = 30;
                return false;
            }

            if (rsiOverbought < 50 || rsiOverbought > 90) {
                logActivity('RSI overbought must be between 50 and 90', 'error');
                document.getElementById('rsiOverbought').value = 70;
                return false;
            }

            if (trendLookback < 3 || trendLookback > 20) {
                logActivity('Trend lookback must be between 3 and 20', 'error');
                document.getElementById('trendLookback').value = 5;
                return false;
            }

            if (durationValue < 1) {
                logActivity('Duration value must be at least 1', 'error');
                document.getElementById('durationValue').value = 1;
                return false;
            }

            return true;
        }

        // Add input validation listeners
        document.getElementById('stakeAmount').addEventListener('blur', validateInputs);
        document.getElementById('stopLoss').addEventListener('blur', validateInputs);
        document.getElementById('takeProfit').addEventListener('blur', validateInputs);
        document.getElementById('rsiPeriod').addEventListener('blur', validateInputs);
        document.getElementById('rsiOversold').addEventListener('blur', validateInputs);
        document.getElementById('rsiOverbought').addEventListener('blur', validateInputs);
        document.getElementById('trendLookback').addEventListener('blur', validateInputs);
        document.getElementById('durationValue').addEventListener('blur', validateInputs);

        // Monitor WebSocket health
        function checkWebSocketHealth() {
            if (isLoggedIn && ws && ws.readyState === WebSocket.OPEN) {
                const timeSinceLastMessage = Date.now() - lastHeartbeat;
                
                if (timeSinceLastMessage > 30000) {
                    ws.send(JSON.stringify({ ping: 1 }));
                }

                if (timeSinceLastMessage > 60000) {
                    logActivity('No response from server. Connection may be lost.', 'warning');
                }
            }
        }

        setInterval(checkWebSocketHealth, 10000);

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                e.preventDefault();
                saveSettings();
                logActivity('Settings saved manually', 'success');
            }

            if ((e.ctrlKey || e.metaKey) && e.key === ' ') {
                e.preventDefault();
                if (isLoggedIn && document.getElementById('autoTradeBtn').disabled === false) {
                    if (isAutoTrading) {
                        stopAutoTrading();
                    } else {
                        startAutoTrading();
                    }
                }
            }

            if ((e.ctrlKey || e.metaKey) && e.key === 'r') {
                e.preventDefault();
                if (isLoggedIn && document.getElementById('reverseModeBtn').disabled === false) {
                    isReverseMode = !isReverseMode;
                    updateReverseModeButton();
                    updateReverseModeIndicator();
                    saveSettings();
                    
                    if (isReverseMode) {
                        logActivity('Reverse Mode ENABLED via keyboard shortcut', 'success');
                    } else {
                        logActivity('Reverse Mode DISABLED via keyboard shortcut', 'info');
                    }
                }
            }
        });

        // Visual connection status
        function updateConnectionStatus() {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                document.body.style.borderTop = '3px solid #ff4757';
            } else {
                document.body.style.borderTop = '3px solid #2ecc71';
            }
        }

        setInterval(updateConnectionStatus, 1000);

        // Error boundaries
        window.addEventListener('error', (e) => {
            logActivity(`Unexpected error: ${e.message}`, 'error');
            console.error('Error details:', e);
        });

        window.addEventListener('unhandledrejection', (e) => {
            logActivity(`Unhandled promise rejection: ${e.reason}`, 'error');
            console.error('Promise rejection details:', e);
        });

        // Export trade history
        window.exportTradeHistory = function() {
            if (tradeHistory.length === 0) {
                logActivity('No trade history to export', 'error');
                return;
            }

            const csv = [
                ['S/N', 'Time', 'Market', 'Type', 'Stake', 'Result'],
                ...tradeHistory.map((trade, index) => [
                    index + 1,
                    trade.time,
                    trade.market,
                    trade.type,
                    trade.stake,
                    trade.result
                ])
            ].map(row => row.join(',')).join('\n');

            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `ben-sniper-trades-${new Date().toISOString().split('T')[0]}.csv`;
            a.click();
            URL.revokeObjectURL(url);

            logActivity('Trade history exported successfully', 'success');
        };

        // Reset all settings
        window.resetAllSettings = function() {
            if (confirm('Are you sure you want to reset all settings to default? This will clear all saved data including trade history.')) {
                sessionStorage.clear();
                location.reload();
            }
        };

        // Tooltips
        const tooltips = {
            'stakeAmount': 'Amount to stake per trade (minimum 0.35)',
            'stopLoss': 'Stop trading when total loss reaches this amount',
            'takeProfit': 'Stop trading when total profit reaches this amount',
            'rsiPeriod': 'RSI calculation period (5-50)',
            'rsiOversold': 'RSI oversold level - Buy only if RSI < this value (10-50)',
            'rsiOverbought': 'RSI overbought level - Sell only if RSI > this value (50-90)',
            'trendLookback': 'Number of candles to analyze for trend structure (3-20)',
            'durationType': 'Unit of time for trade duration',
            'durationValue': 'Number of units for trade duration',
            'rsiFilter': 'RSI Filter: Buy when RSI<Oversold, Sell when RSI>Overbought',
            'trendStructureFilter': 'Trend Structure: Sell at HH+HL (uptrend), Buy at LL+LH (downtrend)',
            'zeroClosingFilter': 'Only trade on PERFECT candle closes (exactly 0 opposite wick)',
            'ignoreHeightFilter': 'Allow confirmation candle to be any height',
            'lengthFilter': 'Confirmation candle height must be ‚â§ first candle height',
            'reverseCandleFilter': 'Reverse candle color pattern: Buy = Green‚ÜíRed, Sell = Red‚ÜíGreen',
            'reverseModeBtn': 'Reverse all signals: Buy becomes Sell, Sell becomes Buy'
        };

        Object.entries(tooltips).forEach(([id, text]) => {
            const element = document.getElementById(id);
            if (element) {
                element.title = text;
            }
        });

        // Responsive font sizing
        function adjustFontSizes() {
            const width = window.innerWidth;
            const root = document.documentElement;
            
            if (width < 480) {
                root.style.fontSize = '14px';
            } else if (width < 768) {
                root.style.fontSize = '15px';
            } else {
                root.style.fontSize = '16px';
            }
        }

        window.addEventListener('resize', adjustFontSizes);
        adjustFontSizes();

        // Network status monitoring
        window.addEventListener('online', () => {
            logActivity('Network connection restored', 'success');
            updateConnectionBadge('connected');
            
            if (isLoggedIn && (!ws || ws.readyState !== WebSocket.OPEN)) {
                const token = sessionStorage.getItem('derivToken');
                if (token) {
                    logActivity('Attempting to reconnect...', 'info');
                    connectWebSocket(token, true).catch(err => {
                        logActivity('Reconnection failed', 'error');
                    });
                }
            }
        });

        window.addEventListener('offline', () => {
            logActivity('Network connection lost!', 'error');
            updateConnectionBadge('disconnected');
        });

        // Auto-reconnect on page refresh/reload
        window.addEventListener('beforeunload', () => {
            saveSettings();
        });

        window.addEventListener('load', () => {
            const savedToken = sessionStorage.getItem('derivToken');
            const wasAutoTrading = sessionStorage.getItem('wasAutoTrading');
            
            if (savedToken && !isLoggedIn) {
                document.getElementById('apiToken').value = savedToken;
                logActivity('Saved token found. Click Login to reconnect.', 'info');
                
                // Auto-login on page refresh if token exists
                setTimeout(() => {
                    document.getElementById('loginBtn').click();
                }, 500);
            }
        });

        // Initialize app
        loadSettings();
        renderMarkets();
        logActivity('System initialized. Please login to continue.', 'success');

        // Log system information
        logActivity(`Browser: ${navigator.userAgent}`, 'info');
        logActivity(`Screen resolution: ${window.screen.width}x${window.screen.height}`, 'info');
        logActivity(`Available markets: ${Object.keys(markets).length}`, 'info');

        // Log startup complete
        setTimeout(() => {
            logActivity('Ben Sniper Bot initialized successfully!', 'success');
            logActivity('NEW: RSI Filter replaces EMA - Buy<30 Oversold, Sell>70 Overbought', 'success');
            logActivity('NEW: Trend Structure Filter - Sell@HH+HL, Buy@LL+LH', 'success');
            logActivity('NEW: Enhanced Auto-Reconnect with exponential backoff', 'success');
            logActivity('Features: RSI, Trend Structure, Zero Closing, Length, Reverse Candle', 'success');
            logActivity('Tip: Press Ctrl+Space to toggle auto trading', 'info');
            logActivity('Tip: Press Ctrl+R to toggle reverse mode', 'info');
            logActivity('Tip: Use exportTradeHistory() in console to export trades', 'info');
            logActivity('App ID: 116948 | All systems operational', 'success');
        }, 1000);
    </script>
</body>
</html>